#!/usr/bin/env bash
# test-docker-session — integration tests for gc-session-docker
#
# Usage: ./scripts/test-docker-session
#
# Exercises the exec provider protocol against the Docker session script.
# Requires: docker, jq
#
# Builds a minimal test image inline with tmux for session management.

set -euo pipefail

SCRIPT="$(cd "$(dirname "$0")" && pwd)/gc-session-docker"
SESSION="gc-docker-test"
TEST_IMAGE="gc-test-agent"
TEST_IMAGE_NOTMUX="gc-test-agent-notmux"

pass=0
fail=0

check() {
    local desc="$1" expected="$2" got="$3"
    if [ "$got" = "$expected" ]; then
        echo "  PASS: $desc"
        ((pass++)) || true
    else
        echo "  FAIL: $desc (expected '$expected', got '$got')"
        ((fail++)) || true
    fi
}

check_contains() {
    local desc="$1" needle="$2" haystack="$3"
    if echo "$haystack" | grep -qF "$needle"; then
        echo "  PASS: $desc"
        ((pass++)) || true
    else
        echo "  FAIL: $desc (expected to contain '$needle', got '$haystack')"
        ((fail++)) || true
    fi
}

check_not_empty() {
    local desc="$1" got="$2"
    if [ -n "$got" ]; then
        echo "  PASS: $desc (got '$got')"
        ((pass++)) || true
    else
        echo "  FAIL: $desc (expected non-empty, got empty)"
        ((fail++)) || true
    fi
}

BUILD_CTX=""

cleanup() {
    echo ""
    echo "--- Cleanup ---"
    "$SCRIPT" stop "$SESSION" 2>/dev/null || true
    "$SCRIPT" stop "${SESSION}-ready" 2>/dev/null || true
    "$SCRIPT" stop "${SESSION}-delay" 2>/dev/null || true
    "$SCRIPT" stop "${SESSION}-nohints" 2>/dev/null || true
    "$SCRIPT" stop "${SESSION}-proc" 2>/dev/null || true
    "$SCRIPT" stop "${SESSION}-setup" 2>/dev/null || true
    "$SCRIPT" stop "${SESSION}-dead" 2>/dev/null || true
    "$SCRIPT" stop "${SESSION}-nudge" 2>/dev/null || true
    "$SCRIPT" stop "${SESSION}-peek0" 2>/dev/null || true
    "$SCRIPT" stop "${SESSION}-idem" 2>/dev/null || true
    "$SCRIPT" stop "${SESSION}-notmux" 2>/dev/null || true
    "$SCRIPT" stop "${SESSION}-activity" 2>/dev/null || true
    "$SCRIPT" stop "${SESSION}-clear" 2>/dev/null || true
    "$SCRIPT" stop "${SESSION}-tmuxsetup" 2>/dev/null || true
    "$SCRIPT" stop "${SESSION}-script" 2>/dev/null || true
    [ -n "$BUILD_CTX" ] && rm -rf "$BUILD_CTX"
}
trap cleanup EXIT

echo "=== gc-session-docker integration tests ==="
echo "Script: $SCRIPT"
echo ""

# --- Build test images ---
echo "--- Building test images ---"
BUILD_CTX=$(mktemp -d)

# Entrypoint script: prints prompt then sleeps.
cat > "$BUILD_CTX/entrypoint.sh" <<'ENTRY'
#!/bin/sh
echo "Initializing..."
sleep 1
echo "> "
exec sleep 300
ENTRY
chmod +x "$BUILD_CTX/entrypoint.sh"

# Delay entrypoint: prints output then sleeps.
cat > "$BUILD_CTX/delay-entrypoint.sh" <<'ENTRY'
#!/bin/sh
echo "delayed start"
exec sleep 300
ENTRY
chmod +x "$BUILD_CTX/delay-entrypoint.sh"

# Scroll entrypoint: generates enough output to fill scrollback.
cat > "$BUILD_CTX/scroll-entrypoint.sh" <<'ENTRY'
#!/bin/sh
for i in $(seq 1 50); do echo "scrollline-$i"; done
echo "SCROLL_DONE"
exec sleep 300
ENTRY
chmod +x "$BUILD_CTX/scroll-entrypoint.sh"

# Primary image: Alpine + procps + tmux.
cat > "$BUILD_CTX/Dockerfile" <<'DOCKERFILE'
FROM alpine:latest
RUN apk add --no-cache procps tmux bash
COPY entrypoint.sh /entrypoint.sh
COPY delay-entrypoint.sh /delay-entrypoint.sh
COPY scroll-entrypoint.sh /scroll-entrypoint.sh
CMD ["/entrypoint.sh"]
DOCKERFILE

docker build -t "$TEST_IMAGE" "$BUILD_CTX"
echo "  OK: built $TEST_IMAGE (with tmux)"

# Secondary image: no tmux (for requirement check test).
cat > "$BUILD_CTX/Dockerfile.notmux" <<'DOCKERFILE'
FROM alpine:latest
RUN apk add --no-cache procps
CMD ["sleep", "300"]
DOCKERFILE

docker build -t "$TEST_IMAGE_NOTMUX" -f "$BUILD_CTX/Dockerfile.notmux" "$BUILD_CTX"
echo "  OK: built $TEST_IMAGE_NOTMUX (without tmux)"
echo ""

# =====================================================================
# Test: pre-pull check (missing image)
# =====================================================================
echo "--- pre-pull check (missing image) ---"
config=$(cat <<EOF
{
    "command": "echo hi",
    "work_dir": "/tmp",
    "env": { "GC_DOCKER_IMAGE": "gc-nonexistent-image-42:latest" }
}
EOF
)
rc=0
echo "$config" | "$SCRIPT" start "${SESSION}-prepull" 2>/dev/null || rc=$?
check "pre-pull fails on missing image" "1" "$rc"
"$SCRIPT" stop "${SESSION}-prepull" 2>/dev/null || true

# =====================================================================
# Test: tmux requirement (image without tmux)
# =====================================================================
echo "--- tmux requirement check ---"
config=$(cat <<EOF
{
    "command": "sleep 300",
    "work_dir": "/tmp",
    "env": {
        "GC_DOCKER_IMAGE": "$TEST_IMAGE_NOTMUX",
        "GC_DOCKER_HOME_MOUNT": "false"
    }
}
EOF
)
rc=0
err=$(echo "$config" | "$SCRIPT" start "${SESSION}-notmux" 2>&1) || rc=$?
check "tmux requirement fails on image without tmux" "1" "$rc"
check_contains "error mentions tmux" "tmux not found" "$err"
"$SCRIPT" stop "${SESSION}-notmux" 2>/dev/null || true

# =====================================================================
# Test: start with ready_prompt_prefix
# =====================================================================
echo "--- start with ready_prompt_prefix ---"
config=$(cat <<EOF
{
    "command": "/entrypoint.sh",
    "work_dir": "/tmp",
    "ready_prompt_prefix": "> ",
    "env": {
        "GC_DOCKER_IMAGE": "$TEST_IMAGE",
        "GC_DOCKER_HOME_MOUNT": "false"
    }
}
EOF
)
echo "$config" | "$SCRIPT" start "${SESSION}-ready"
echo "  PASS: start with prompt prefix (no error)"
((pass++)) || true

running=$("$SCRIPT" is-running "${SESSION}-ready")
check "prompt-detected container is running" "true" "$running"
"$SCRIPT" stop "${SESSION}-ready" 2>/dev/null || true

# =====================================================================
# Test: start with process_names
# =====================================================================
echo "--- start with process_names ---"
config=$(cat <<EOF
{
    "command": "/entrypoint.sh",
    "work_dir": "/tmp",
    "process_names": ["sleep"],
    "env": {
        "GC_DOCKER_IMAGE": "$TEST_IMAGE",
        "GC_DOCKER_HOME_MOUNT": "false"
    }
}
EOF
)
echo "$config" | "$SCRIPT" start "${SESSION}-proc"
echo "  PASS: start with process_names (no error)"
((pass++)) || true

running=$("$SCRIPT" is-running "${SESSION}-proc")
check "process-detected container is running" "true" "$running"
"$SCRIPT" stop "${SESSION}-proc" 2>/dev/null || true

# =====================================================================
# Test: start with ready_delay_ms
# =====================================================================
echo "--- start with ready_delay_ms ---"
config=$(cat <<EOF
{
    "command": "/delay-entrypoint.sh",
    "work_dir": "/tmp",
    "ready_delay_ms": 1000,
    "env": {
        "GC_DOCKER_IMAGE": "$TEST_IMAGE",
        "GC_DOCKER_HOME_MOUNT": "false"
    }
}
EOF
)
start_time=$SECONDS
echo "$config" | "$SCRIPT" start "${SESSION}-delay"
elapsed=$((SECONDS - start_time))
if [ "$elapsed" -ge 1 ]; then
    echo "  PASS: ready_delay_ms waited ~${elapsed}s"
    ((pass++)) || true
else
    echo "  FAIL: ready_delay_ms waited only ${elapsed}s (expected >= 1)"
    ((fail++)) || true
fi
"$SCRIPT" stop "${SESSION}-delay" 2>/dev/null || true

# =====================================================================
# Test: start with no hints (fire-and-forget)
# =====================================================================
echo "--- start with no hints ---"
config=$(cat <<EOF
{
    "command": "sleep 300",
    "work_dir": "/tmp",
    "env": {
        "GC_DOCKER_IMAGE": "$TEST_IMAGE",
        "GC_DOCKER_HOME_MOUNT": "false"
    }
}
EOF
)
echo "$config" | "$SCRIPT" start "${SESSION}-nohints"
echo "  PASS: start with no hints (no error)"
((pass++)) || true

running=$("$SCRIPT" is-running "${SESSION}-nohints")
check "no-hints container is running" "true" "$running"
"$SCRIPT" stop "${SESSION}-nohints" 2>/dev/null || true

# =====================================================================
# Test: start idempotency (start twice → second is no-op)
# =====================================================================
echo "--- start idempotency ---"
config=$(cat <<EOF
{
    "command": "sleep 300",
    "work_dir": "/tmp",
    "env": {
        "GC_DOCKER_IMAGE": "$TEST_IMAGE",
        "GC_DOCKER_HOME_MOUNT": "false"
    }
}
EOF
)
echo "$config" | "$SCRIPT" start "${SESSION}-idem"
# Get container ID.
cid1=$(docker inspect -f '{{.Id}}' "${SESSION}-idem" 2>/dev/null || echo "")

# Start again — should be a no-op (same container).
echo "$config" | "$SCRIPT" start "${SESSION}-idem"
cid2=$(docker inspect -f '{{.Id}}' "${SESSION}-idem" 2>/dev/null || echo "")

check "start idempotency (same container)" "$cid1" "$cid2"
"$SCRIPT" stop "${SESSION}-idem" 2>/dev/null || true

# =====================================================================
# Test: container labels
# =====================================================================
echo "--- container labels ---"
config=$(cat <<EOF
{
    "command": "/entrypoint.sh",
    "work_dir": "/tmp",
    "ready_prompt_prefix": "> ",
    "env": {
        "GC_DOCKER_IMAGE": "$TEST_IMAGE",
        "GC_DOCKER_HOME_MOUNT": "false"
    }
}
EOF
)
echo "$config" | "$SCRIPT" start "$SESSION"
label_managed=$(docker inspect -f '{{index .Config.Labels "gc.managed"}}' "$SESSION" 2>/dev/null || echo "MISSING")
label_agent=$(docker inspect -f '{{index .Config.Labels "gc.agent"}}' "$SESSION" 2>/dev/null || echo "MISSING")
check "gc.managed label" "true" "$label_managed"
check "gc.agent label" "$SESSION" "$label_agent"

# =====================================================================
# Test: is-running (uses container from above)
# =====================================================================
echo "--- is-running ---"
running=$("$SCRIPT" is-running "$SESSION")
check "container is running" "true" "$running"

# =====================================================================
# Test: peek
# =====================================================================
echo "--- peek ---"
output=$("$SCRIPT" peek "$SESSION" 5)
check_contains "peek shows output" "Initializing" "$output"

# =====================================================================
# Test: peek with lines=0 (capture all)
# =====================================================================
echo "--- peek lines=0 ---"
config=$(cat <<EOF
{
    "command": "/entrypoint.sh",
    "work_dir": "/tmp",
    "ready_prompt_prefix": "> ",
    "env": {
        "GC_DOCKER_IMAGE": "$TEST_IMAGE",
        "GC_DOCKER_HOME_MOUNT": "false"
    }
}
EOF
)
echo "$config" | "$SCRIPT" start "${SESSION}-peek0"
sleep 0.5
output=$("$SCRIPT" peek "${SESSION}-peek0" 0)
check_contains "peek lines=0 captures output" "Initializing" "$output"
"$SCRIPT" stop "${SESSION}-peek0" 2>/dev/null || true

# =====================================================================
# Test: process-alive with specific process name
# =====================================================================
echo "--- process-alive ---"
alive=$(echo "sleep" | "$SCRIPT" process-alive "$SESSION")
check "process-alive (sleep)" "true" "$alive"

alive=$(echo "nonexistent-process-xyz" | "$SCRIPT" process-alive "$SESSION")
check "process-alive (nonexistent)" "false" "$alive"

# =====================================================================
# Test: process-alive via tmux pane_current_command
# =====================================================================
echo "--- process-alive (tmux pane command) ---"
# The entrypoint execs sleep, so pane_current_command should be "sleep".
pane_cmd=$(docker exec -e "TMUX_TMPDIR=/run/gc-tmux" "$SESSION" tmux -u \
    display-message -t "agent:0.0" -p '#{pane_current_command}' 2>/dev/null || echo "")
echo "  (pane_current_command='$pane_cmd')"
alive=$(echo "$pane_cmd" | "$SCRIPT" process-alive "$SESSION")
check "process-alive via pane command" "true" "$alive"

# =====================================================================
# Test: set-meta / get-meta
# =====================================================================
echo "--- set-meta / get-meta ---"
echo -n "test-value-42" | "$SCRIPT" set-meta "$SESSION" "my-key"
got=$("$SCRIPT" get-meta "$SESSION" "my-key")
check "meta round-trip" "test-value-42" "$got"

# =====================================================================
# Test: get-meta (missing key)
# =====================================================================
echo "--- get-meta (missing key) ---"
got=$("$SCRIPT" get-meta "$SESSION" "no-such-key")
check "missing meta is empty" "" "$got"

# =====================================================================
# Test: remove-meta
# =====================================================================
echo "--- remove-meta ---"
"$SCRIPT" remove-meta "$SESSION" "my-key"
got=$("$SCRIPT" get-meta "$SESSION" "my-key")
check "removed meta is empty" "" "$got"

# =====================================================================
# Test: nudge delivers text to agent
# =====================================================================
echo "--- nudge ---"
config=$(cat <<EOF
{
    "command": "cat",
    "work_dir": "/tmp",
    "env": {
        "GC_DOCKER_IMAGE": "$TEST_IMAGE",
        "GC_DOCKER_HOME_MOUNT": "false"
    }
}
EOF
)
echo "$config" | "$SCRIPT" start "${SESSION}-nudge"
sleep 0.5

# Send a nudge message.
echo -n "hello-from-nudge" | "$SCRIPT" nudge "${SESSION}-nudge"
sleep 1

# Verify the message appears in the pane output.
output=$("$SCRIPT" peek "${SESSION}-nudge" 20)
check_contains "nudge delivers text" "hello-from-nudge" "$output"
"$SCRIPT" stop "${SESSION}-nudge" 2>/dev/null || true

# =====================================================================
# Test: get-last-activity returns RFC3339 timestamp
# =====================================================================
echo "--- get-last-activity ---"
config=$(cat <<EOF
{
    "command": "sleep 300",
    "work_dir": "/tmp",
    "env": {
        "GC_DOCKER_IMAGE": "$TEST_IMAGE",
        "GC_DOCKER_HOME_MOUNT": "false"
    }
}
EOF
)
echo "$config" | "$SCRIPT" start "${SESSION}-activity"
sleep 0.5
activity=$("$SCRIPT" get-last-activity "${SESSION}-activity")
# Should be a valid RFC3339 timestamp (YYYY-MM-DDTHH:MM:SSZ).
if echo "$activity" | grep -qE '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$'; then
    echo "  PASS: get-last-activity returns RFC3339 ($activity)"
    ((pass++)) || true
else
    echo "  FAIL: get-last-activity expected RFC3339, got '$activity'"
    ((fail++)) || true
fi
"$SCRIPT" stop "${SESSION}-activity" 2>/dev/null || true

# =====================================================================
# Test: clear-scrollback
# =====================================================================
echo "--- clear-scrollback ---"
# Use scroll-entrypoint which generates 50 lines + SCROLL_DONE, pushing
# early lines into tmux scrollback (default pane is ~24 lines).
config=$(cat <<EOF
{
    "command": "/scroll-entrypoint.sh",
    "work_dir": "/tmp",
    "ready_prompt_prefix": "SCROLL_DONE",
    "env": {
        "GC_DOCKER_IMAGE": "$TEST_IMAGE",
        "GC_DOCKER_HOME_MOUNT": "false"
    }
}
EOF
)
echo "$config" | "$SCRIPT" start "${SESSION}-clear"

# Verify early lines are in scrollback (capture all).
before=$("$SCRIPT" peek "${SESSION}-clear" 0)
check_contains "scrollback contains early lines" "scrollline-1" "$before"

# Clear scrollback.
"$SCRIPT" clear-scrollback "${SESSION}-clear"

# After clearing, early scrollback lines should be gone.
after=$("$SCRIPT" peek "${SESSION}-clear" 0)
if echo "$after" | grep -qF "scrollline-1"; then
    echo "  FAIL: clear-scrollback did not clear scrollback"
    ((fail++)) || true
else
    echo "  PASS: clear-scrollback cleared history"
    ((pass++)) || true
fi
"$SCRIPT" stop "${SESSION}-clear" 2>/dev/null || true

# =====================================================================
# Test: list-running
# =====================================================================
echo "--- list-running ---"
listed=$("$SCRIPT" list-running "gc-docker-test")
check_contains "list-running finds session" "$SESSION" "$listed"

# =====================================================================
# Test: session_setup runs inside container (via docker exec)
# =====================================================================
echo "--- session setup (inside container) ---"
# The marker path is bind-mounted (/tmp:/tmp), so a touch inside the
# container is visible on the host. This validates that session_setup
# commands execute inside the container, not on the host.
setup_marker="/tmp/gc-dkr-setup-marker-$$"
rm -f "$setup_marker" 2>/dev/null || true
config=$(cat <<EOF
{
    "command": "sleep 300",
    "work_dir": "/tmp",
    "session_setup": ["touch $setup_marker"],
    "env": {
        "GC_DOCKER_IMAGE": "$TEST_IMAGE",
        "GC_DOCKER_HOME_MOUNT": "false"
    }
}
EOF
)
"$SCRIPT" stop "${SESSION}-setup" 2>/dev/null || true
echo "$config" | "$SCRIPT" start "${SESSION}-setup"
if [ -f "$setup_marker" ]; then
    echo "  PASS: session setup created marker file (via container)"
    ((pass++)) || true
else
    echo "  FAIL: session setup marker not found"
    ((fail++)) || true
fi
rm -f "$setup_marker" 2>/dev/null || true
"$SCRIPT" stop "${SESSION}-setup" 2>/dev/null || true

# =====================================================================
# Test: session_setup rewrites tmux targets for in-container tmux
# =====================================================================
echo "--- session setup (tmux target rewriting) ---"
# The session_setup command targets the expanded session name
# (gc-docker-test-tmuxsetup). The Docker provider rewrites it to
# target the in-container tmux session ("agent").
config=$(cat <<EOF
{
    "command": "sleep 300",
    "work_dir": "/tmp",
    "session_setup": ["tmux set-option -t ${SESSION}-tmuxsetup status-right 'DOCKER_SETUP_OK'"],
    "env": {
        "GC_DOCKER_IMAGE": "$TEST_IMAGE",
        "GC_DOCKER_HOME_MOUNT": "false"
    }
}
EOF
)
"$SCRIPT" stop "${SESSION}-tmuxsetup" 2>/dev/null || true
echo "$config" | "$SCRIPT" start "${SESSION}-tmuxsetup"
# Verify the option was applied to the in-container "agent" session.
got=$(docker exec -e "TMUX_TMPDIR=/run/gc-tmux" "${SESSION}-tmuxsetup" \
    tmux -u show-options -t agent -v status-right 2>/dev/null || echo "")
check_contains "tmux target rewritten to in-container session" "DOCKER_SETUP_OK" "$got"
"$SCRIPT" stop "${SESSION}-tmuxsetup" 2>/dev/null || true

# =====================================================================
# Test: session_setup_script piped from host into container
# =====================================================================
echo "--- session_setup_script (host file piped to container) ---"
# Create a host-side script that touches a marker file.
# The script runs inside the container via docker exec -i ... sh < script.
script_marker="/tmp/gc-dkr-script-marker-$$"
rm -f "$script_marker" 2>/dev/null || true
setup_script_file=$(mktemp)
cat > "$setup_script_file" <<SCRIPT
#!/bin/sh
touch $script_marker
SCRIPT
chmod +x "$setup_script_file"

config=$(cat <<EOF
{
    "command": "sleep 300",
    "work_dir": "/tmp",
    "session_setup_script": "$setup_script_file",
    "env": {
        "GC_DOCKER_IMAGE": "$TEST_IMAGE",
        "GC_DOCKER_HOME_MOUNT": "false"
    }
}
EOF
)
"$SCRIPT" stop "${SESSION}-script" 2>/dev/null || true
echo "$config" | "$SCRIPT" start "${SESSION}-script"
if [ -f "$script_marker" ]; then
    echo "  PASS: session_setup_script executed inside container"
    ((pass++)) || true
else
    echo "  FAIL: session_setup_script marker not found"
    ((fail++)) || true
fi
rm -f "$script_marker" 2>/dev/null || true
rm -f "$setup_script_file"
"$SCRIPT" stop "${SESSION}-script" 2>/dev/null || true

# =====================================================================
# Test: TERM propagated to container
# =====================================================================
echo "--- TERM propagation ---"
# TERM should be set in the container (default xterm-256color).
term_val=$(docker inspect -f '{{range .Config.Env}}{{println .}}{{end}}' "$SESSION" 2>/dev/null \
    | grep '^TERM=' | head -1 || echo "")
check_contains "TERM set in container" "TERM=" "$term_val"

# =====================================================================
# Test: interrupt
# =====================================================================
echo "--- interrupt ---"
"$SCRIPT" interrupt "$SESSION"
sleep 0.5
echo "  PASS: interrupt (no error)"
((pass++)) || true

# =====================================================================
# Test: unknown operation (forward compat)
# =====================================================================
echo "--- unknown operation ---"
rc=0
"$SCRIPT" future-op "$SESSION" 2>/dev/null || rc=$?
check "unknown op exits 2" "2" "$rc"

# =====================================================================
# Test: stop
# =====================================================================
echo "--- stop ---"
"$SCRIPT" stop "$SESSION"
sleep 0.5
running=$("$SCRIPT" is-running "$SESSION")
check "stopped container is not running" "false" "$running"

# =====================================================================
# Test: stop idempotent
# =====================================================================
echo "--- stop (idempotent) ---"
"$SCRIPT" stop "$SESSION"
echo "  PASS: double stop (no error)"
((pass++)) || true

echo ""
echo "=== Results: $pass passed, $fail failed ==="
[ "$fail" -eq 0 ]
