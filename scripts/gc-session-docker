#!/usr/bin/env bash
# gc-session-docker — Docker session provider for Gas City (tmux-in-Docker)
#
# Usage:
#   GC_SESSION=exec:scripts/gc-session-docker gc start
#
# Implements the Gas City exec session provider protocol (see
# internal/session/exec/exec.go). Each agent runs in its own Docker
# container with tmux providing session management inside the container.
#
# Architecture:
#   docker run -d --init $image sleep infinity     # container stays alive
#   docker exec tmux new-session -d -s agent ...   # agent runs inside tmux
#
# Process tree: tini → sleep infinity (PID 1) + tmux-server → agent
# One tmux session per container, always named "agent".
#
# Requirements: docker, jq
# Container requirement: tmux (hard error if missing)
#
# Configuration via agent env vars (set in city.toml [[agents]] env):
#   GC_DOCKER_IMAGE      — container image (default: gc-agent:latest)
#   GC_DOCKER_NETWORK    — Docker network name (optional)
#   GC_DOCKER_EXTRA      — extra docker-run flags (optional, space-separated)
#   GC_DOCKER_HOME_MOUNT — mount $HOME read-only (default: true)
#   GC_DOCKER_USER       — container user (e.g. "1000:1000") (optional)

set -euo pipefail

# Default image if not specified in agent env.
DEFAULT_IMAGE="gc-agent:latest"

# Tmux session name inside each container (one agent per container).
TMUX_SESSION="agent"

# Socket directory for tmux inside containers. /run is a container-local
# tmpfs, so sockets are isolated even when /tmp is volume-mounted from
# the host.
TMUX_SOCK_DIR="/run/gc-tmux"

# --- Helpers ---

die() { echo "$*" >&2; exit 1; }

# Parse a JSON field from config.
# Usage: field <json> <path> [default]
field() {
    local val
    val=$(echo "$1" | jq -r "$2 // empty" 2>/dev/null) || true
    if [ -z "$val" ]; then
        echo "${3:-}"
    else
        echo "$val"
    fi
}

# Parse a JSON array field as newline-separated values.
# Usage: field_array <json> <path>
field_array() {
    echo "$1" | jq -r "$2 // [] | .[]" 2>/dev/null || true
}

# Sanitize container name: Docker allows [a-zA-Z0-9][a-zA-Z0-9_.-] only.
sanitize_name() {
    local name
    name=$(echo "$1" | tr -c 'a-zA-Z0-9_.-' '-')
    # Strip leading non-alphanumeric chars (Docker requirement).
    name="${name#"${name%%[a-zA-Z0-9]*}"}"
    # Strip trailing dashes for cleanliness.
    name="${name%"${name##*[a-zA-Z0-9_.]}"}"
    echo "${name:-gc-unnamed}"
}

# Execute tmux inside a container with isolated socket directory.
# Prevents conflicts when host /tmp is volume-mounted.
# Usage: dtmux [-it] <container> <tmux-args...>
dtmux() {
    local docker_flags=()
    if [[ "${1:-}" == "-it" ]]; then
        docker_flags+=(-i -t)
        shift
    fi
    local cname="$1"
    shift
    docker exec "${docker_flags[@]+"${docker_flags[@]}"}" \
        -e "TMUX_TMPDIR=$TMUX_SOCK_DIR" \
        "$cname" tmux -u "$@"
}

# Send literal text to tmux pane with retry on transient errors.
# Usage: send_keys_with_retry <container> <text>
send_keys_with_retry() {
    local cname="$1" text="$2"
    local attempt=0 max_attempts=5 delay=0.5
    while [ $attempt -lt $max_attempts ]; do
        if dtmux "$cname" send-keys -t "$TMUX_SESSION" -l "$text" 2>/dev/null; then
            return 0
        fi
        ((attempt++)) || true
        sleep "$delay"
        # Exponential backoff capped at 2s (mirrors tmux adapter).
        delay=$(awk "BEGIN {d=$delay*1.5; if(d>2) d=2; printf \"%.1f\", d}")
    done
    return 1  # all retries exhausted
}

# Wake a detached tmux session via SIGWINCH (resize trick).
# In Docker, the tmux session is always detached (no client attached).
# Claude Code's TUI processes stdin on SIGWINCH, so this ensures nudge
# delivery is picked up.
wake_pane() {
    local cname="$1"
    dtmux "$cname" resize-pane -t "$TMUX_SESSION" -y -1 2>/dev/null || true
    sleep 0.05
    dtmux "$cname" resize-pane -t "$TMUX_SESSION" -y +1 2>/dev/null || true
}

# Check if path A is the same as or under path B.
# Usage: is_under <path> <parent>
is_under() {
    case "$1" in
        "$2"|"$2/"*) return 0 ;;
        *) return 1 ;;
    esac
}

# --- Readiness detection (tmux-based) ---

# Wait for the agent process to appear in the tmux pane.
# Usage: wait_for_process <container> <process_name> <timeout_sec>
wait_for_process() {
    local cname="$1" pname="$2" timeout_sec="$3"
    local deadline=$((SECONDS + timeout_sec))
    while [ $SECONDS -lt $deadline ]; do
        # Check tmux pane_current_command first.
        local cmd
        cmd=$(dtmux "$cname" display-message \
            -t "$TMUX_SESSION:0.0" -p '#{pane_current_command}' 2>/dev/null) || true
        if [ "$cmd" = "$pname" ]; then
            return 0
        fi
        # Fallback: pgrep inside container.
        if docker exec "$cname" pgrep -x "$pname" >/dev/null 2>&1; then
            return 0
        fi
        sleep 0.2
    done
    # Best-effort: non-fatal timeout (matches tmux adapter).
    return 0
}

# Wait for ANY of the given process names to appear in the tmux pane.
# Checks all names in a single timeout window instead of sequential per-name
# timeouts (which stack to N×30s on failure).
# Usage: wait_for_any_process <container> <timeout_sec> <name1> [name2...]
wait_for_any_process() {
    local cname="$1" timeout_sec="$2"
    shift 2
    local names=("$@")
    local deadline=$((SECONDS + timeout_sec))
    while [ $SECONDS -lt $deadline ]; do
        local cmd
        cmd=$(dtmux "$cname" display-message \
            -t "$TMUX_SESSION:0.0" -p '#{pane_current_command}' 2>/dev/null) || true
        for pname in "${names[@]}"; do
            [ -z "$pname" ] && continue
            if [ "$cmd" = "$pname" ]; then return 0; fi
            if docker exec "$cname" pgrep -x "$pname" >/dev/null 2>&1; then return 0; fi
        done
        sleep 0.2
    done
    # Best-effort: non-fatal timeout (matches tmux adapter).
    return 0
}

# Wait for a prompt prefix in tmux pane output.
# Usage: wait_for_prompt <container> <prefix> <timeout_sec>
wait_for_prompt() {
    local cname="$1" prefix="$2" timeout_sec="$3"
    local deadline=$((SECONDS + timeout_sec))
    while [ $SECONDS -lt $deadline ]; do
        if dtmux "$cname" capture-pane -p \
            -t "$TMUX_SESSION" -S -10 2>/dev/null | grep -qF "$prefix"; then
            return 0
        fi
        sleep 0.2
    done
    # Best-effort: non-fatal timeout.
    return 0
}

# --- Operations ---

do_start() {
    local name="$1"
    local config
    config=$(cat)

    local cname
    cname=$(sanitize_name "$name")

    # Parse config fields from JSON on stdin.
    local command work_dir image network extra home_mount
    command=$(field "$config" '.command' 'sh')
    work_dir=$(field "$config" '.work_dir' '/workspace')
    image=$(field "$config" '.env.GC_DOCKER_IMAGE' "$DEFAULT_IMAGE")
    network=$(field "$config" '.env.GC_DOCKER_NETWORK' '')
    extra=$(field "$config" '.env.GC_DOCKER_EXTRA' '')
    home_mount=$(field "$config" '.env.GC_DOCKER_HOME_MOUNT' 'true')
    docker_user=$(field "$config" '.env.GC_DOCKER_USER' '')

    # Parse readiness hints.
    local ready_prefix ready_delay_ms
    ready_prefix=$(field "$config" '.ready_prompt_prefix' '')
    ready_delay_ms=$(field "$config" '.ready_delay_ms' '0')

    # Pre-pull check: fail fast if image not local.
    docker image inspect "$image" >/dev/null 2>&1 ||
        die "image '$image' not found locally. Run: docker pull $image"

    # --- Start idempotency ---
    # If container is running and tmux session is alive, leave it alone.
    if docker inspect -f '{{.State.Running}}' "$cname" 2>/dev/null | grep -q true; then
        if dtmux "$cname" has-session -t "=$TMUX_SESSION" 2>/dev/null; then
            return 0  # healthy — idempotent no-op
        fi
    fi

    # Remove stale container.
    docker rm -f "$cname" >/dev/null 2>&1 || true

    # --- Null-delimited env parsing (handles values with newlines) ---
    local env_args=()
    while IFS= read -r -d '' entry; do
        [ -n "$entry" ] && env_args+=(-e "$entry")
    done < <(echo "$config" | jq -j '.env // {} | to_entries[] | "\(.key)=\(.value)\u0000"')

    # Build volume mounts — same host path inside the container.
    local vol_args=()
    if [ -n "$work_dir" ] && [ -d "$work_dir" ]; then
        vol_args+=(-v "$work_dir:$work_dir")
    fi

    local city_path
    city_path=$(field "$config" '.env.GC_CITY' '')
    if [ -n "$city_path" ] && [ -d "$city_path" ]; then
        # Skip if city_path is under work_dir (already mounted), or exact match.
        if ! is_under "$city_path" "$work_dir"; then
            vol_args+=(-v "$city_path:$city_path")
        fi
    fi

    # Mount $HOME read-only for API keys, git config, SSH keys.
    # Skip if $HOME is the same as work_dir or city_path — the RO mount
    # would shadow the RW mount, making the workdir read-only.
    if [ "$home_mount" = "true" ] && [ -n "${HOME:-}" ] && [ -d "$HOME" ]; then
        local skip_home=false
        if [ "$HOME" = "$work_dir" ]; then
            skip_home=true
        elif [ -n "$city_path" ] && [ "$HOME" = "$city_path" ]; then
            skip_home=true
        fi
        if [ "$skip_home" = "false" ]; then
            vol_args+=(-v "$HOME:$HOME:ro")
            # Overlay $HOME/.claude as writable so Claude can persist workspace
            # trust state and session data. Docker mount ordering ensures the
            # more specific path shadows the RO parent mount.
            if [ -d "$HOME/.claude" ]; then
                vol_args+=(-v "$HOME/.claude:$HOME/.claude")
            fi
        fi
    fi

    # Network flag.
    local net_args=()
    if [ -n "$network" ]; then
        net_args+=(--network "$network")
    fi

    # Extra flags (space-separated, unquoted expansion is intentional).
    local extra_args=()
    if [ -n "$extra" ]; then
        # shellcheck disable=SC2206
        extra_args=($extra)
    fi

    # Start container with sleep infinity (PID 1 keepalive).
    # TERM is set as a default; config env can override (last -e wins).
    docker run -d \
        --name "$cname" \
        --init \
        ${docker_user:+--user "$docker_user"} \
        --label gc.managed=true \
        --label "gc.agent=$name" \
        -e "TERM=${TERM:-xterm-256color}" \
        "${vol_args[@]+"${vol_args[@]}"}" \
        "${env_args[@]+"${env_args[@]}"}" \
        "${net_args[@]+"${net_args[@]}"}" \
        "${extra_args[@]+"${extra_args[@]}"}" \
        -w "$work_dir" \
        "$image" \
        sleep infinity \
        >/dev/null

    # --- Tmux requirement check ---
    docker exec "$cname" which tmux >/dev/null 2>&1 ||
        die "tmux not found in image '$image'. Install: apk add tmux (Alpine) or apt-get install -y tmux (Debian)"

    # Create isolated tmux socket directory inside the container.
    # Use --user 0 (root) because /run may not be writable by the container
    # user (e.g., when --user is set). Sticky bit (1777) lets any user create
    # sockets inside the directory.
    docker exec --user 0 "$cname" sh -c "mkdir -p '$TMUX_SOCK_DIR' && chmod 1777 '$TMUX_SOCK_DIR'"

    # Build tmux env flags (-e KEY=val).
    local tmux_env_args=()
    while IFS= read -r -d '' entry; do
        [ -n "$entry" ] && tmux_env_args+=(-e "$entry")
    done < <(echo "$config" | jq -j '.env // {} | to_entries[] | "\(.key)=\(.value)\u0000"')

    # Tell the agent which tmux session to target for metadata (drain,
    # restart). The controller uses TMUX_SESSION ("agent") when proxying
    # set-meta/get-meta; this env var makes the agent's Go tmux provider
    # resolve to the same session name.
    tmux_env_args+=(-e "GC_TMUX_SESSION=$TMUX_SESSION")

    # --- File staging (overlay + copy_files) ---
    # Must happen BEFORE tmux session start so the agent script sees the
    # files. Docker bind-mounts make host-side copies visible immediately.
    overlay_dir=$(field "$config" '.overlay_dir' '')
    if [ -n "$overlay_dir" ] && [ -d "$overlay_dir" ]; then
        cp -r "$overlay_dir/." "$work_dir/" 2>/dev/null || true
    fi

    echo "$config" | jq -c '.copy_files // [] | .[]' 2>/dev/null | while IFS= read -r entry; do
        [ -z "$entry" ] && continue
        src=$(echo "$entry" | jq -r '.src')
        rel_dst=$(echo "$entry" | jq -r '.rel_dst // ""')
        dst="$work_dir"
        [ -n "$rel_dst" ] && dst="$work_dir/$rel_dst"
        if [ -d "$src" ]; then
            mkdir -p "$dst"
            cp -r "$src/." "$dst/" 2>/dev/null || true
        elif [ -f "$src" ]; then
            mkdir -p "$(dirname "$dst")"
            cp "$src" "$dst" 2>/dev/null || true
        fi
    done

    # --- Pre-start commands (directory/worktree preparation) ---
    # Run before session creation, matching the native tmux adapter contract.
    local pre_start_cmds
    pre_start_cmds=$(field_array "$config" '.pre_start')
    if [ -n "$pre_start_cmds" ]; then
        local pre_exec_env=(-w "$work_dir")
        while IFS= read -r -d '' entry; do
            [ -n "$entry" ] && pre_exec_env+=(-e "$entry")
        done < <(echo "$config" | jq -j '.env // {} | to_entries[] | "\(.key)=\(.value)\u0000"')
        while IFS= read -r cmd; do
            [ -n "$cmd" ] || continue
            docker exec "${pre_exec_env[@]}" "$cname" \
                timeout 10 sh -c "$cmd" 2>/dev/null || true
        done <<< "$pre_start_cmds"
    fi

    # Start the agent inside tmux. Use exec to eliminate intermediate sh.
    dtmux "$cname" new-session -d -s "$TMUX_SESSION" \
        -c "$work_dir" \
        "${tmux_env_args[@]+"${tmux_env_args[@]}"}" \
        -- sh -c "exec $command"

    # --- Readiness detection (mirrors tmux adapter doStartSession) ---

    # Step 1: Wait for ANY process name to appear (single 30s window).
    local pnames
    pnames=$(field_array "$config" '.process_names')
    if [ -n "$pnames" ]; then
        local pname_array=()
        while IFS= read -r pname; do
            [ -n "$pname" ] && pname_array+=("$pname")
        done <<< "$pnames"
        [ ${#pname_array[@]} -gt 0 ] && wait_for_any_process "$cname" 30 "${pname_array[@]}"
    fi

    # Step 2: Wait for prompt prefix (if set).
    if [ -n "$ready_prefix" ]; then
        wait_for_prompt "$cname" "$ready_prefix" 60
    elif [ "$ready_delay_ms" -gt 0 ] 2>/dev/null; then
        # Step 3: Fallback delay (if ready_delay_ms set, no prefix).
        local delay_sec
        delay_sec=$(awk "BEGIN {printf \"%.3f\", $ready_delay_ms / 1000}")
        sleep "$delay_sec"
    fi

    # Step 4: Verify container and tmux session survived startup.
    local running
    running=$(docker inspect -f '{{.State.Running}}' "$cname" 2>/dev/null) || running="false"
    if [ "$running" != "true" ]; then
        local logs
        logs=$(docker logs --tail 5 "$cname" 2>&1 || true)
        die "container '$cname' died during startup. Logs: $logs"
    fi
    if ! dtmux "$cname" has-session -t "=$TMUX_SESSION" 2>/dev/null; then
        local pane_output
        pane_output=$(dtmux "$cname" capture-pane -p \
            -t "$TMUX_SESSION" -S -10 2>/dev/null || true)
        die "tmux session died during startup. Last output: $pane_output"
    fi

    # Enable remain-on-exit for crash forensics.
    dtmux "$cname" set-option -t "$TMUX_SESSION" remain-on-exit on \
        2>/dev/null || true

    # Step 5: Run session_setup commands inside the container.
    # Commands run via docker exec with tmux targets rewritten from
    # the expanded session name (e.g., "gastown-mayor") to the
    # in-container tmux session name ("agent"). This lets the same
    # city.toml work with both tmux and Docker providers.
    local setup_cmds
    setup_cmds=$(field_array "$config" '.session_setup')
    if [ -n "$setup_cmds" ]; then
        # Build docker exec env flags for setup commands.
        local setup_exec_env=(-e "TMUX_TMPDIR=$TMUX_SOCK_DIR")
        while IFS= read -r -d '' entry; do
            [ -n "$entry" ] && setup_exec_env+=(-e "$entry")
        done < <(echo "$config" | jq -j '.env // {} | to_entries[] | "\(.key)=\(.value)\u0000"')
        setup_exec_env+=(-e "GC_SESSION=$TMUX_SESSION")

        # Escape regex metacharacters in the session name for sed.
        local escaped_name
        escaped_name=$(printf '%s' "$name" | sed 's/[.[\*^$]/\\&/g')

        while IFS= read -r cmd; do
            [ -n "$cmd" ] || continue
            # Rewrite tmux -t targets only: expanded session name →
            # in-container name. Blanket ${cmd//$name/...} would corrupt
            # file paths or string arguments that happen to contain the
            # session name.
            local rewritten
            rewritten=$(printf '%s' "$cmd" \
                | sed -E "s/(-t[[:space:]]*=?)${escaped_name}/\1${TMUX_SESSION}/g")
            docker exec "${setup_exec_env[@]}" "$cname" \
                timeout 10 sh -c "$rewritten" 2>/dev/null || true
        done <<< "$setup_cmds"
    fi

    local setup_script
    setup_script=$(field "$config" '.session_setup_script' '')
    if [ -n "$setup_script" ]; then
        # session_setup_script is a host-side file path (resolved by the
        # controller). Read it locally and pipe into the container, matching
        # the K8s provider pattern.
        if [ -f "$setup_script" ]; then
            local setup_exec_env=(-i -e "TMUX_TMPDIR=$TMUX_SOCK_DIR")
            while IFS= read -r -d '' entry; do
                [ -n "$entry" ] && setup_exec_env+=(-e "$entry")
            done < <(echo "$config" | jq -j '.env // {} | to_entries[] | "\(.key)=\(.value)\u0000"')
            setup_exec_env+=(-e "GC_SESSION=$TMUX_SESSION")

            docker exec "${setup_exec_env[@]}" "$cname" \
                timeout 10 sh < "$setup_script" 2>/dev/null || true
        else
            echo "gc: session_setup_script warning: $setup_script not found on controller" >&2
        fi
    fi

    # Step 6: Nudge delivery (best-effort, mirrors tmux adapter).
    local nudge
    nudge=$(field "$config" '.nudge' '')
    if [ -n "$nudge" ]; then
        send_keys_with_retry "$cname" "$nudge" || true
        sleep 0.5
        dtmux "$cname" send-keys -t "$TMUX_SESSION" Enter 2>/dev/null || true
        wake_pane "$cname"
    fi
}

do_stop() {
    local cname
    cname=$(sanitize_name "$1")

    # Graceful stop (SIGTERM → 10s grace → SIGKILL) then remove.
    docker stop -t 10 "$cname" >/dev/null 2>&1 || true
    docker rm -f "$cname" >/dev/null 2>&1 || true
}

do_interrupt() {
    local cname
    cname=$(sanitize_name "$1")

    # Send Ctrl-C to the tmux pane (mirrors tmux adapter).
    dtmux "$cname" send-keys -t "$TMUX_SESSION" C-c \
        2>/dev/null || true
}

do_is_running() {
    local cname
    cname=$(sanitize_name "$1")

    local running
    running=$(docker inspect -f '{{.State.Running}}' "$cname" 2>/dev/null) || running="false"
    # Trim whitespace — docker inspect may output trailing newlines.
    printf '%s' "$running" | tr -d '[:space:]'
}

do_process_alive() {
    local cname
    cname=$(sanitize_name "$1")

    # Read process names from stdin (one per line).
    local names
    names=$(cat)

    # Empty names → true (per protocol: no check possible).
    if [ -z "$names" ]; then
        echo "true"
        return
    fi

    # Check tmux pane_current_command first (matches tmux adapter pattern).
    local pane_cmd
    pane_cmd=$(dtmux "$cname" display-message \
        -t "$TMUX_SESSION:0.0" -p '#{pane_current_command}' 2>/dev/null) || pane_cmd=""

    while IFS= read -r pname || [ -n "$pname" ]; do
        [ -z "$pname" ] && continue
        # Check pane command.
        if [ "$pane_cmd" = "$pname" ]; then
            echo "true"
            return
        fi
        # Fallback: pgrep inside container.
        if docker exec "$cname" pgrep -x "$pname" >/dev/null 2>&1; then
            echo "true"
            return
        fi
    done <<< "$names"

    echo "false"
}

do_nudge() {
    local cname
    cname=$(sanitize_name "$1")

    local message
    message=$(cat)

    # Full nudge protocol (mirrors tmux adapter NudgeSession):
    # 1. Send literal text with retry (handles "not in a mode" startup race).
    send_keys_with_retry "$cname" "$message" || true

    # 2. Debounce: wait for paste completion (empirically required).
    sleep 0.5

    # 3. Escape: exit vim INSERT mode (harmless in normal mode).
    dtmux "$cname" send-keys -t "$TMUX_SESSION" Escape 2>/dev/null || true
    sleep 0.1

    # 4. Enter with retry.
    local i
    for i in 0 1 2; do
        [ "$i" -gt 0 ] && sleep 0.2
        if dtmux "$cname" send-keys -t "$TMUX_SESSION" Enter 2>/dev/null; then
            break
        fi
    done

    # 5. Wake detached session via SIGWINCH (resize trick).
    # In Docker, the tmux session is always detached (no client attached).
    # Claude Code's TUI processes stdin on SIGWINCH.
    wake_pane "$cname"
}

do_peek() {
    local cname lines
    cname=$(sanitize_name "$1")
    lines="${2:-50}"

    # Peek with lines <= 0 returns all output.
    if [ "$lines" -le 0 ] 2>/dev/null; then
        # Capture all scrollback.
        dtmux "$cname" capture-pane -p \
            -t "$TMUX_SESSION" -S - 2>/dev/null || true
    else
        # Capture last N lines.
        dtmux "$cname" capture-pane -p \
            -t "$TMUX_SESSION" -S "-$lines" 2>/dev/null || true
    fi
}

do_attach() {
    local cname
    cname=$(sanitize_name "$1")

    # Attach to the tmux session inside the container.
    dtmux -it "$cname" attach-session -t "$TMUX_SESSION"
}

do_set_meta() {
    local cname key value
    cname=$(sanitize_name "$1")
    key="$2"
    value=$(cat)

    # Store in tmux environment inside the container. This is the same
    # store the agent's default tmux provider reads, so both controller
    # (via this script) and agent (via gc agent drain-check) see the
    # same metadata.
    dtmux "$cname" set-environment -t "$TMUX_SESSION" "$key" "$value" \
        2>/dev/null || true
}

do_get_meta() {
    local cname key
    cname=$(sanitize_name "$1")
    key="$2"

    # Read from tmux environment inside the container.
    # Output format: KEY=VALUE (set), -KEY (unset), or error (never set).
    local output
    output=$(dtmux "$cname" show-environment -t "$TMUX_SESSION" "$key" \
        2>/dev/null) || return 0
    case "$output" in
        -*)    ;; # explicitly unset — return empty
        *=*)   printf '%s' "${output#*=}" ;;
    esac
    # Empty stdout + exit 0 = key not set (per protocol).
}

do_remove_meta() {
    local cname key
    cname=$(sanitize_name "$1")
    key="$2"

    dtmux "$cname" set-environment -t "$TMUX_SESSION" -u "$key" \
        2>/dev/null || true
}

do_list_running() {
    local prefix="$1"

    # List running containers managed by gc with our naming prefix.
    docker ps --filter "status=running" \
              --filter "label=gc.managed=true" \
              --format '{{.Names}}' 2>/dev/null \
        | grep "^${prefix}" \
        | sort \
        || true
}

do_get_last_activity() {
    local cname
    cname=$(sanitize_name "$1")

    # Get session_activity (Unix epoch) from tmux and convert to RFC3339.
    local epoch
    epoch=$(dtmux "$cname" display-message \
        -t "$TMUX_SESSION" -p '#{session_activity}' 2>/dev/null) || epoch=""

    if [ -n "$epoch" ] && [ "$epoch" -gt 0 ] 2>/dev/null; then
        # Convert epoch to RFC3339. Try GNU date first, then BSD date.
        date -u -d "@$epoch" '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null ||
            date -u -r "$epoch" '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null ||
            true
    fi
    # Empty stdout = zero time (per protocol).
}

do_clear_scrollback() {
    local cname
    cname=$(sanitize_name "$1")

    # Clear tmux history buffer.
    dtmux "$cname" clear-history -t "$TMUX_SESSION" \
        2>/dev/null || true
}

# --- Dispatch ---

op="${1:-}"
shift || true

case "$op" in
    start)              do_start "$@" ;;
    stop)               do_stop "$@" ;;
    interrupt)          do_interrupt "$@" ;;
    is-running)         do_is_running "$@" ;;
    process-alive)      do_process_alive "$@" ;;
    nudge)              do_nudge "$@" ;;
    peek)               do_peek "$@" ;;
    attach)             do_attach "$@" ;;
    set-meta)           do_set_meta "$@" ;;
    get-meta)           do_get_meta "$@" ;;
    remove-meta)        do_remove_meta "$@" ;;
    list-running)       do_list_running "$@" ;;
    get-last-activity)  do_get_last_activity "$@" ;;
    clear-scrollback)   do_clear_scrollback "$@" ;;
    check-image)
        # Pre-check: verify image exists locally before starting agents.
        # Called once per unique image before the reconcile loop.
        image="${1:-$DEFAULT_IMAGE}"
        docker image inspect "$image" >/dev/null 2>&1 ||
            die "image '$image' not found locally. Run: docker pull $image"
        ;;
    copy-to)
        # Copy a file or directory into the named container's workdir.
        # Docker bind-mounts make host-side copies visible, but for
        # containers without bind-mounts, use docker cp as fallback.
        cname=$(sanitize_name "$1")
        src="$2"
        rel_dst="${3:-}"
        if [ -z "$src" ]; then exit 0; fi
        # Try host-side copy first (works with bind-mounted workdirs).
        # Fall back to docker cp if needed.
        work_dir=$(docker inspect -f '{{range .Config.Env}}{{println .}}{{end}}' "$cname" 2>/dev/null \
            | grep '^GC_DIR=' | head -1 | cut -d= -f2-)
        if [ -n "$work_dir" ] && [ -d "$work_dir" ]; then
            dst="$work_dir"
            [ -n "$rel_dst" ] && dst="$work_dir/$rel_dst"
            if [ -d "$src" ]; then
                mkdir -p "$dst"
                cp -r "$src/." "$dst/" 2>/dev/null || true
            elif [ -f "$src" ]; then
                mkdir -p "$(dirname "$dst")"
                cp "$src" "$dst" 2>/dev/null || true
            fi
        else
            # No bind-mount — use docker cp.
            dst="/workspace"
            [ -n "$rel_dst" ] && dst="/workspace/$rel_dst"
            docker exec "$cname" mkdir -p "$dst" 2>/dev/null || true
            if [ -d "$src" ]; then
                docker cp "$src/." "$cname:$dst/" 2>/dev/null || true
            elif [ -f "$src" ]; then
                docker cp "$src" "$cname:$dst" 2>/dev/null || true
            fi
        fi
        ;;
    *)
        # Unknown operation — exit 2 for forward compatibility.
        exit 2
        ;;
esac
