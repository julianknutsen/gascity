package config

import (
	"crypto/sha256"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/BurntSushi/toml"
)

// topologyCacheDir is the subdirectory under .gc/ where remote topologies are cached.
const topologyCacheDir = "topologies"

// TopologyLock represents the lockfile state for reproducible builds.
type TopologyLock struct {
	Topologies map[string]LockedTopology `toml:"topologies"`
}

// LockedTopology records the exact state of a cached topology.
type LockedTopology struct {
	Source string `toml:"source"`
	Ref    string `toml:"ref"`
	Commit string `toml:"commit"`
	Hash   string `toml:"hash"`
}

// FetchTopologies ensures all remote topologies are cached locally.
// Clones missing repos and updates existing ones to match the declared ref.
func FetchTopologies(topologies map[string]TopologySource, cityRoot string) error {
	cacheRoot := filepath.Join(cityRoot, ".gc", topologyCacheDir)
	if err := os.MkdirAll(cacheRoot, 0o755); err != nil {
		return fmt.Errorf("creating topology cache dir: %w", err)
	}

	for name, src := range topologies {
		cacheDir := filepath.Join(cacheRoot, name)
		if _, err := os.Stat(filepath.Join(cacheDir, ".git")); err != nil {
			// Not yet cloned.
			if err := cloneTopology(src.Source, cacheDir, src.Ref); err != nil {
				return fmt.Errorf("topology %q: %w", name, err)
			}
		} else {
			// Already cloned â€” update to declared ref.
			if err := updateTopology(cacheDir, src.Ref); err != nil {
				return fmt.Errorf("topology %q: %w", name, err)
			}
		}
	}
	return nil
}

// cloneTopology clones a git repo and checks out the specified ref.
func cloneTopology(source, cacheDir, ref string) error {
	args := []string{"clone"}
	if ref != "" {
		args = append(args, "--branch", ref)
	}
	args = append(args, "--depth", "1", source, cacheDir)

	if _, err := runGit("", args...); err != nil {
		return fmt.Errorf("cloning %s: %w", source, err)
	}
	return nil
}

// updateTopology fetches and checks out the specified ref.
func updateTopology(cacheDir, ref string) error {
	if _, err := runGit(cacheDir, "fetch", "origin"); err != nil {
		return fmt.Errorf("fetching: %w", err)
	}
	target := ref
	if target == "" {
		target = "origin/HEAD"
	}
	// Try checkout as-is first (for tags/branches).
	if _, err := runGit(cacheDir, "checkout", target); err != nil {
		// If that fails, try origin/<ref> for branch names.
		if _, err2 := runGit(cacheDir, "checkout", "origin/"+ref); err2 != nil {
			return fmt.Errorf("checking out %q: %w", ref, err)
		}
	}
	return nil
}

// TopologyCachePath returns the cache directory for a named topology.
func TopologyCachePath(cityRoot, name string, src TopologySource) string {
	dir := filepath.Join(cityRoot, ".gc", topologyCacheDir, name)
	if src.Path != "" {
		dir = filepath.Join(dir, src.Path)
	}
	return dir
}

// ReadLock reads topology.lock from the city root.
// Returns an empty lock (not error) if the file doesn't exist.
func ReadLock(cityRoot string) (*TopologyLock, error) {
	path := filepath.Join(cityRoot, "topology.lock")
	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return &TopologyLock{Topologies: make(map[string]LockedTopology)}, nil
		}
		return nil, fmt.Errorf("reading topology.lock: %w", err)
	}
	var lock TopologyLock
	if _, err := toml.Decode(string(data), &lock); err != nil {
		return nil, fmt.Errorf("parsing topology.lock: %w", err)
	}
	if lock.Topologies == nil {
		lock.Topologies = make(map[string]LockedTopology)
	}
	return &lock, nil
}

// WriteLock writes topology.lock to the city root atomically.
func WriteLock(cityRoot string, lock *TopologyLock) error {
	path := filepath.Join(cityRoot, "topology.lock")
	tmp := path + ".tmp"

	f, err := os.Create(tmp)
	if err != nil {
		return fmt.Errorf("creating topology.lock: %w", err)
	}

	fmt.Fprintln(f, "# Auto-generated by gc topology fetch. Commit for reproducibility.") //nolint:errcheck
	fmt.Fprintln(f)                                                                       //nolint:errcheck

	enc := toml.NewEncoder(f)
	enc.Indent = ""
	if err := enc.Encode(lock); err != nil {
		f.Close()      //nolint:errcheck
		os.Remove(tmp) //nolint:errcheck // best-effort cleanup
		return fmt.Errorf("encoding topology.lock: %w", err)
	}
	if err := f.Close(); err != nil {
		os.Remove(tmp) //nolint:errcheck // best-effort cleanup
		return fmt.Errorf("closing topology.lock: %w", err)
	}
	return os.Rename(tmp, path)
}

// LockFromCache builds lock state from current cache contents.
func LockFromCache(topologies map[string]TopologySource, cityRoot string) (*TopologyLock, error) {
	lock := &TopologyLock{Topologies: make(map[string]LockedTopology)}
	cacheRoot := filepath.Join(cityRoot, ".gc", topologyCacheDir)

	for name, src := range topologies {
		cacheDir := filepath.Join(cacheRoot, name)
		lt := LockedTopology{
			Source: src.Source,
			Ref:    src.Ref,
		}

		// Get current commit.
		out, err := runGit(cacheDir, "rev-parse", "HEAD")
		if err == nil {
			lt.Commit = strings.TrimSpace(out)
		}

		// Compute content hash.
		topoDir := cacheDir
		if src.Path != "" {
			topoDir = filepath.Join(cacheDir, src.Path)
		}
		lt.Hash = "sha256:" + topologyDirHash(topoDir)

		lock.Topologies[name] = lt
	}
	return lock, nil
}

// topologyDirHash computes a SHA-256 hash of all files in a directory (recursive).
func topologyDirHash(dir string) string {
	var paths []string
	filepath.Walk(dir, func(path string, info os.FileInfo, err error) error { //nolint:errcheck
		if err != nil || info.IsDir() {
			return nil
		}
		rel, err := filepath.Rel(dir, path)
		if err != nil {
			return nil
		}
		// Skip .git directory contents.
		if strings.HasPrefix(rel, ".git") {
			return nil
		}
		paths = append(paths, rel)
		return nil
	})

	h := sha256.New()
	for _, rel := range paths {
		data, err := os.ReadFile(filepath.Join(dir, rel))
		if err != nil {
			continue
		}
		h.Write([]byte(rel)) //nolint:errcheck
		h.Write([]byte{0})   //nolint:errcheck
		h.Write(data)        //nolint:errcheck
		h.Write([]byte{0})   //nolint:errcheck
	}
	return fmt.Sprintf("%x", h.Sum(nil))
}

// gitEnvBlacklist lists git environment variables that must be stripped
// so subprocess git commands use the intended workDir, not a parent repo.
var fetchGitEnvBlacklist = map[string]bool{
	"GIT_DIR":                          true,
	"GIT_WORK_TREE":                    true,
	"GIT_INDEX_FILE":                   true,
	"GIT_OBJECT_DIRECTORY":             true,
	"GIT_ALTERNATE_OBJECT_DIRECTORIES": true,
}

// runGit executes a git command with a clean environment.
// If dir is non-empty, the command runs in that directory.
func runGit(dir string, args ...string) (string, error) {
	cmd := exec.Command("git", args...)
	if dir != "" {
		cmd.Dir = dir
	}
	// Build clean env: inherit everything except git-specific vars.
	for _, e := range os.Environ() {
		if k, _, ok := strings.Cut(e, "="); ok && fetchGitEnvBlacklist[k] {
			continue
		}
		cmd.Env = append(cmd.Env, e)
	}
	out, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("git %s: %s: %w", strings.Join(args, " "), strings.TrimSpace(string(out)), err)
	}
	return string(out), nil
}
