#!/usr/bin/env bash
# gc-session-k8s — Kubernetes session provider for Gas City.
#
# Implements the exec session provider protocol, mapping each operation
# to kubectl + tmux commands. Agent sessions run as Kubernetes Pods with
# tmux inside the container providing a real terminal session.
#
# Architecture: the pod's entrypoint starts tmux with the agent command.
# All session operations (nudge, peek, attach, interrupt) delegate to
# tmux inside the pod via kubectl exec. This gives identical semantics
# to the local tmux provider — real terminal scrollback, keystroke
# nudge, interactive attach.
#
# See docs/exec-session-protocol.md for the full protocol specification.
#
# Dependencies: kubectl, jq, bash
# Container requirements: tmux, bash
#
# Usage: GC_SESSION=exec:/path/to/gc-session-k8s gc start <city>
#
# Configuration via environment variables:
#
#   GC_K8S_NAMESPACE   - K8s namespace for agent pods (default: gc)
#   GC_K8S_IMAGE       - Container image for agents (required for start)
#   GC_K8S_CONTEXT     - kubectl context (default: current)
#   GC_K8S_DOLT_HOST   - Dolt service DNS (default: dolt.gc.svc.cluster.local)
#   GC_K8S_DOLT_PORT   - Dolt service port (default: 3307)
#   GC_K8S_MCP_MAIL_HOST - mcp-agent-mail service DNS (default: mcp-mail.gc.svc.cluster.local)
#   GC_K8S_MCP_MAIL_PORT - mcp-agent-mail service port (default: 8765)
#   GC_K8S_CPU_REQUEST - Pod CPU request (default: 500m)
#   GC_K8S_MEM_REQUEST - Pod memory request (default: 1Gi)
#   GC_K8S_CPU_LIMIT   - Pod CPU limit (default: 2)
#   GC_K8S_MEM_LIMIT   - Pod memory limit (default: 4Gi)

set -euo pipefail

op="${1:?missing operation}"
name="${2:-}"

# Tmux session name inside each pod (constant — one session per pod).
TMUX_SESSION="main"

# --- Configuration ---

NS="${GC_K8S_NAMESPACE:-gc}"
IMAGE="${GC_K8S_IMAGE:-}"
DOLT_HOST="${GC_K8S_DOLT_HOST:-dolt.gc.svc.cluster.local}"
DOLT_PORT="${GC_K8S_DOLT_PORT:-3307}"
MCP_MAIL_HOST="${GC_K8S_MCP_MAIL_HOST:-mcp-mail.gc.svc.cluster.local}"
MCP_MAIL_PORT="${GC_K8S_MCP_MAIL_PORT:-8765}"
CPU_REQ="${GC_K8S_CPU_REQUEST:-500m}"
MEM_REQ="${GC_K8S_MEM_REQUEST:-1Gi}"
CPU_LIM="${GC_K8S_CPU_LIMIT:-2}"
MEM_LIM="${GC_K8S_MEM_LIMIT:-4Gi}"

# Build kubectl base command with optional context.
KUBECTL=(kubectl)
if [ -n "${GC_K8S_CONTEXT:-}" ]; then
  KUBECTL+=(--context "$GC_K8S_CONTEXT")
fi
KUBECTL+=(-n "$NS")

# --- Helpers ---

# sanitize_name converts a session name to a valid K8s resource name.
# K8s names: lowercase, alphanumeric, '-', max 63 chars, must start/end
# with alphanumeric.
sanitize_name() {
  echo "$1" \
    | tr '[:upper:]' '[:lower:]' \
    | sed 's/[^a-z0-9-]/-/g' \
    | sed 's/^-*//' \
    | sed 's/-*$//' \
    | cut -c1-63 \
    | sed 's/-*$//'
}

# sanitize_label converts a value to a valid K8s label value.
# Label values: alphanumeric, '-', '_', '.', max 63 chars, must start/end
# with alphanumeric. Empty is also valid.
sanitize_label() {
  local v
  v=$(echo "$1" \
    | sed 's/[^a-zA-Z0-9._-]/-/g' \
    | sed 's/^[^a-zA-Z0-9]*//' \
    | sed 's/[^a-zA-Z0-9]*$//' \
    | cut -c1-63 \
    | sed 's/[^a-zA-Z0-9]*$//')
  echo "${v:-unknown}"
}

# pod_name returns the pod name for a session.
pod_name() {
  sanitize_name "$1"
}

# get_pod_name_by_label finds a pod by gc-session label, returns first match.
get_pod_name_by_label() {
  local label
  label=$(sanitize_label "$1")
  "${KUBECTL[@]}" get pods -l "gc-session=$label" \
    --field-selector=status.phase=Running \
    -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true
}

# get_any_pod_by_label finds a pod by gc-session label (any phase).
get_any_pod_by_label() {
  local label
  label=$(sanitize_label "$1")
  "${KUBECTL[@]}" get pods -l "gc-session=$label" \
    -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true
}

# --- Operations ---

case "$op" in
  start)
    # Read JSON config from stdin.
    config=$(cat)
    command=$(echo "$config" | jq -r '.command // ""')
    env_json=$(echo "$config" | jq -c '.env // {}')

    if [ -z "$name" ]; then
      echo "start: missing session name" >&2
      exit 1
    fi
    if [ -z "$IMAGE" ]; then
      echo "start: GC_K8S_IMAGE is required" >&2
      exit 1
    fi

    pod=$(pod_name "$name")
    label=$(sanitize_label "$name")

    # Check if pod already exists (any phase).
    existing=$(get_any_pod_by_label "$label")
    if [ -n "$existing" ]; then
      phase=$("${KUBECTL[@]}" get pod "$existing" -o jsonpath='{.status.phase}' 2>/dev/null || true)
      if [ "$phase" = "Running" ]; then
        # Pod is running — check if tmux session is actually alive.
        # If Claude exited, tmux dies but the pod stays alive (sleep infinity).
        # In that case, clean up and recreate rather than blocking restart.
        if "${KUBECTL[@]}" exec "$existing" -- tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
          echo "session \"$name\" already exists (pod: $existing)" >&2
          exit 1
        fi
        echo "start: stale pod $existing (tmux dead), recreating" >&2
        # Capture last output from the dead session for diagnostics.
        diag=$("${KUBECTL[@]}" exec "$existing" -- \
          tail -30 /tmp/agent-output.log 2>/dev/null) || true
        if [ -n "$diag" ]; then
          echo "start: last output from $existing:" >&2
          echo "$diag" >&2
        fi
      fi
      # Pod is stuck/stale — clean up before recreating.
      "${KUBECTL[@]}" delete pod "$existing" --ignore-not-found >/dev/null 2>&1 || true
      "${KUBECTL[@]}" wait --for=delete "pod/$existing" --timeout=30s >/dev/null 2>&1 || true
    fi

    # Extract agent name from env for labeling.
    gc_agent=$(echo "$env_json" | jq -r '.GC_AGENT // "unknown"')
    gc_agent_label=$(sanitize_label "$gc_agent")

    # No settings path rewriting needed — the command already uses a
    # relative path (--settings .gc/settings.json) and the .gc directory
    # is staged via copy_files before the agent starts.

    # Build pre-start commands from pre_start array.
    # These run on the target filesystem before the tmux session is created.
    pre_start_count=$(echo "$config" | jq -r '.pre_start // [] | length')
    pre_cmds=""
    for i in $(seq 0 $(( pre_start_count - 1 ))); do
      cmd=$(echo "$config" | jq -r ".pre_start[$i]")
      pre_cmds="${pre_cmds}${cmd}; "
    done

    # Pod entrypoint: wait for workspace ready → pre_start → tmux → keepalive.
    # tmux provides a real terminal session — nudge, peek, attach all
    # work via tmux commands through kubectl exec.
    # Base64-encode the command to avoid shell quoting issues with tmux.
    # The sleep infinity keeps the container alive if tmux exits.
    #
    # Claude credentials: secret mounted read-only at /tmp/claude-secret.
    # Copy into writable CLAUDE_CONFIG_DIR so Claude can create runtime
    # state (cache, backups, debug dirs).
    #
    # .gc-workspace-ready sentinel: gc-session-k8s touches this AFTER copying
    # the city dir and running gc init. Without this wait, Claude starts
    # before .beads/ is configured and exits immediately.
    cred_copy="mkdir -p \$HOME/.claude && cp -rL /tmp/claude-secret/. \$HOME/.claude/ 2>/dev/null; "
    ws_wait="while [ ! -f /workspace/.gc-workspace-ready ]; do sleep 0.5; done; "

    cmd_b64=$(printf '%s' "${command:-/bin/bash}" | base64 -w0)
    tmux_cmd="${cred_copy}${ws_wait}${pre_cmds}CMD=\$(echo '${cmd_b64}' | base64 -d) && tmux new-session -d -s ${TMUX_SESSION} \"\$CMD\" && sleep infinity"

    # Build the pod manifest as JSON using jq.
    # All values are properly JSON-escaped by jq — no injection risk.
    # Tell the agent which tmux session to target for metadata (drain,
    # restart). The controller uses TMUX_SESSION ("main") when proxying
    # set-meta/get-meta; this env var makes the agent's Go tmux provider
    # resolve to the same session name.
    # Map controller-side work_dir to pod-side /workspace path.
    # Controller resolves agent dirs relative to its cityPath (e.g., /city),
    # but agent pods use /workspace as the city root. Rig agents need their
    # subpath preserved: /city/demo-rig → /workspace/demo-rig.
    work_dir=$(echo "$config" | jq -r '.work_dir // ""')
    ctrl_city=$(echo "$env_json" | jq -r '.GC_CITY // ""')
    pod_work_dir="/workspace"
    if [ -n "$ctrl_city" ] && [ -n "$work_dir" ] && [ "$work_dir" != "$ctrl_city" ]; then
      case "$work_dir" in
        "${ctrl_city}/"*)
          rel="${work_dir#${ctrl_city}/}"
          pod_work_dir="/workspace/$rel"
          ;;
      esac
    fi

    # Build env array for the pod. Remove controller-only exec providers
    # (GC_BEADS, GC_SESSION, GC_EVENTS) — agents use native bd against dolt.
    # Derive mail project from city name so all agents share one namespace.
    mail_project=$(echo "$env_json" | jq -r '.GC_CITY // "/workspace"')

    env_array=$(echo "$env_json" | jq \
      --arg dolt_host "$DOLT_HOST" \
      --arg dolt_port "$DOLT_PORT" \
      --arg mcp_mail_url "http://${MCP_MAIL_HOST}:${MCP_MAIL_PORT}" \
      --arg mcp_mail_project "$mail_project" \
      --arg tmux_session "$TMUX_SESSION" \
      --arg pod_dir "$pod_work_dir" '
      del(.GC_DOLT_HOST, .GC_DOLT_PORT, .GC_BEADS, .GC_SESSION, .GC_EVENTS,
          .GC_MAIL, .GC_MCP_MAIL_URL, .GC_MCP_MAIL_PROJECT)
      | .GC_CITY = "/workspace" | .GC_DIR = $pod_dir
      | to_entries
      | map({name: .key, value: (.value | tostring)})
      + [{name: "GC_DOLT_HOST", value: $dolt_host},
         {name: "GC_DOLT_PORT", value: $dolt_port},
         {name: "GC_MCP_MAIL_URL", value: $mcp_mail_url},
         {name: "GC_MCP_MAIL_PROJECT", value: $mcp_mail_project},
         {name: "GC_MAIL", value: "exec:gc-mail-mcp-agent-mail"},
         {name: "GC_TMUX_SESSION", value: $tmux_session},
         {name: "CLAUDE_CONFIG_DIR", value: "/home/gcagent/.claude"}]
    ')

    # Determine the working directory for the main container.
    # Use the work_dir from config (host path) so that $GC_CITY and $GC_DIR
    # resolve correctly inside the pod — the emptyDir volume is mounted at
    # this path, making host-path env vars valid pod-local paths.
    work_dir=$(echo "$config" | jq -r '.work_dir // "/workspace"')
    gc_city=$(echo "$env_json" | jq -r '.GC_CITY // ""')

    # Check if we need staging (overlay_dir, copy_files, or rig workdir).
    overlay_dir=$(echo "$config" | jq -r '.overlay_dir // ""')
    copy_files_count=$(echo "$config" | jq '.copy_files // [] | length')
    needs_staging=false
    if [ -n "$overlay_dir" ] && [ -d "$overlay_dir" ]; then needs_staging=true; fi
    if [ "$copy_files_count" -gt 0 ]; then needs_staging=true; fi
    # Rig agents have a work_dir subdirectory that must be copied into the pod
    # so that the agent has the rig's files (including .git/).
    if [ -n "$work_dir" ] && [ -d "$work_dir" ] && [ "$work_dir" != "$ctrl_city" ]; then
      needs_staging=true
    fi

    # Build the pod manifest. When files need staging, use an init container
    # that waits for a sentinel file (.gc-ready) before exiting. The
    # controller copies files into the shared emptyDir volume via the init
    # container, then touches the sentinel. This guarantees all files are
    # in place before the main container starts — no race, no send-keys.
    # Build volume mounts for the main container. The emptyDir is mounted
    # at $work_dir so host-path env vars ($GC_CITY, $GC_DIR) resolve to
    # valid paths inside the pod. If GC_CITY differs from work_dir (agent
    # has a custom dir), add a second mount so $GC_CITY is also valid.
    main_vol_mounts='[{name: "ws", mountPath: $wd}, {name: "claude-config", mountPath: "/tmp/claude-secret", readOnly: true}]'
    extra_jq_args=(--arg wd "$work_dir")
    if [ -n "$gc_city" ] && [ "$gc_city" != "$work_dir" ]; then
      main_vol_mounts='[{name: "ws", mountPath: $wd}, {name: "city", mountPath: $city}, {name: "claude-config", mountPath: "/tmp/claude-secret", readOnly: true}]'
      extra_jq_args+=(--arg city "$gc_city")
    fi

    if [ "$needs_staging" = "true" ]; then
      # Build volumes list — always include ws emptyDir + claude-config secret.
      # Add a second emptyDir for GC_CITY when it differs from work_dir.
      vol_spec='[{name: "ws", emptyDir: {}}, {name: "claude-config", secret: {secretName: "claude-credentials", optional: true}}]'
      init_vol_mounts='[{name: "ws", mountPath: "/workspace"}]'
      if [ -n "$gc_city" ] && [ "$gc_city" != "$work_dir" ]; then
        vol_spec='[{name: "ws", emptyDir: {}}, {name: "city", emptyDir: {}}, {name: "claude-config", secret: {secretName: "claude-credentials", optional: true}}]'
        init_vol_mounts='[{name: "ws", mountPath: "/workspace"}, {name: "city", mountPath: "/city-stage"}]'
      fi
      manifest=$(jq -n \
        --arg pod "$pod" \
        --arg ns "$NS" \
        --arg label "$label" \
        --arg gc_agent_label "$gc_agent_label" \
        --arg session_name "$name" \
        --arg image "$IMAGE" \
        --arg cmd "$tmux_cmd" \
        --arg cpu_req "$CPU_REQ" \
        --arg mem_req "$MEM_REQ" \
        --arg cpu_lim "$CPU_LIM" \
        --arg mem_lim "$MEM_LIM" \
        --arg work_dir "$pod_work_dir" \
        --argjson env "$env_array" \
        "${extra_jq_args[@]}" \
        '{
          apiVersion: "v1",
          kind: "Pod",
          metadata: {
            name: $pod,
            namespace: $ns,
            labels: {
              app: "gc-agent",
              "gc-session": $label,
              "gc-agent": $gc_agent_label
            },
            annotations: {
              "gc-session-name": $session_name
            }
          },
          spec: {
            restartPolicy: "Never",
            initContainers: [{
              name: "stage",
              image: $image,
              imagePullPolicy: "IfNotPresent",
              command: ["sh", "-c",
                "while [ ! -f /workspace/.gc-ready ]; do sleep 0.5; done"],
              volumeMounts: '"$init_vol_mounts"'
            }],
            containers: [{
              name: "agent",
              image: $image,
              imagePullPolicy: "IfNotPresent",
              workingDir: $wd,
              command: ["/bin/sh", "-c"],
              args: [$cmd],
              env: $env,
              stdin: true,
              tty: true,
              resources: {
                requests: {cpu: $cpu_req, memory: $mem_req},
                limits: {cpu: $cpu_lim, memory: $mem_lim}
              },
              volumeMounts: '"$main_vol_mounts"'
            }],
            volumes: '"$vol_spec"'
          }
        }')
    else
      # No staging needed — simpler pod without init container.
      # Still mount emptyDir at work_dir for consistent path semantics.
      vol_spec='[{name: "ws", emptyDir: {}}, {name: "claude-config", secret: {secretName: "claude-credentials", optional: true}}]'
      if [ -n "$gc_city" ] && [ "$gc_city" != "$work_dir" ]; then
        vol_spec='[{name: "ws", emptyDir: {}}, {name: "city", emptyDir: {}}, {name: "claude-config", secret: {secretName: "claude-credentials", optional: true}}]'
      fi
      manifest=$(jq -n \
        --arg pod "$pod" \
        --arg ns "$NS" \
        --arg label "$label" \
        --arg gc_agent_label "$gc_agent_label" \
        --arg session_name "$name" \
        --arg image "$IMAGE" \
        --arg cmd "$tmux_cmd" \
        --arg cpu_req "$CPU_REQ" \
        --arg mem_req "$MEM_REQ" \
        --arg cpu_lim "$CPU_LIM" \
        --arg mem_lim "$MEM_LIM" \
        --arg work_dir "$pod_work_dir" \
        --argjson env "$env_array" \
        "${extra_jq_args[@]}" \
        '{
          apiVersion: "v1",
          kind: "Pod",
          metadata: {
            name: $pod,
            namespace: $ns,
            labels: {
              app: "gc-agent",
              "gc-session": $label,
              "gc-agent": $gc_agent_label
            },
            annotations: {
              "gc-session-name": $session_name
            }
          },
          spec: {
            restartPolicy: "Never",
            containers: [{
              name: "agent",
              image: $image,
              imagePullPolicy: "IfNotPresent",
              workingDir: $wd,
              command: ["/bin/sh", "-c"],
              args: [$cmd],
              env: $env,
              stdin: true,
              tty: true,
              resources: {
                requests: {cpu: $cpu_req, memory: $mem_req},
                limits: {cpu: $cpu_lim, memory: $mem_lim}
              },
              volumeMounts: '"$main_vol_mounts"'
            }],
            volumes: '"$vol_spec"'
          }
        }')
    fi

    echo "$manifest" | "${KUBECTL[@]}" apply -f - >/dev/null

    # --- File staging via init container ---
    if [ "$needs_staging" = "true" ]; then
      # Wait for the init container to be running.
      for i in $(seq 1 60); do
        phase=$("${KUBECTL[@]}" get pod "$pod" \
          -o jsonpath='{.status.initContainerStatuses[0].state.running}' 2>/dev/null || true)
        [ -n "$phase" ] && break
        if [ "$i" -eq 60 ]; then
          echo "start: init container not running in pod $pod after 60s" >&2
          exit 1
        fi
        sleep 1
      done

      # Copy rig work_dir into the pod so rig agents get the full directory
      # contents including .git/.
      if [ -n "$work_dir" ] && [ -d "$work_dir" ] && [ "$work_dir" != "$ctrl_city" ]; then
        "${KUBECTL[@]}" exec "$pod" -c stage -- mkdir -p "$pod_work_dir" 2>/dev/null || true
        "${KUBECTL[@]}" cp "$work_dir/." "$pod:$pod_work_dir/" -c stage 2>/dev/null || \
          echo "start: warning: failed to copy work_dir $work_dir" >&2
      fi

      # Copy overlay_dir into /workspace/ via init container.
      if [ -n "$overlay_dir" ] && [ -d "$overlay_dir" ]; then
        "${KUBECTL[@]}" cp "$overlay_dir/." "$pod:/workspace/" -c stage 2>/dev/null || \
          echo "start: warning: failed to copy overlay" >&2
      fi

      # Copy each copy_files entry via init container.
      echo "$config" | jq -c '.copy_files // [] | .[]' 2>/dev/null | while IFS= read -r entry; do
        [ -z "$entry" ] && continue
        src=$(echo "$entry" | jq -r '.src')
        rel_dst=$(echo "$entry" | jq -r '.rel_dst // ""')
        dst="/workspace"
        [ -n "$rel_dst" ] && dst="/workspace/$rel_dst"
        if [ -d "$src" ]; then
          "${KUBECTL[@]}" exec "$pod" -c stage -- mkdir -p "$dst" 2>/dev/null || true
          "${KUBECTL[@]}" cp "$src/." "$pod:$dst/" -c stage 2>/dev/null || \
            echo "start: warning: failed to copy $src" >&2
        elif [ -f "$src" ]; then
          parent_dir=$(dirname "$dst")
          "${KUBECTL[@]}" exec "$pod" -c stage -- mkdir -p "$parent_dir" 2>/dev/null || true
          "${KUBECTL[@]}" cp "$src" "$pod:$dst" -c stage 2>/dev/null || \
            echo "start: warning: failed to copy $src" >&2
        fi
      done

      # When GC_CITY differs from work_dir, mirror .gc/ into the city volume
      # so that $GC_CITY/.gc/scripts/ resolves for agents with custom dirs.
      if [ -n "$gc_city" ] && [ "$gc_city" != "$work_dir" ]; then
        "${KUBECTL[@]}" exec "$pod" -c stage -- \
          sh -c 'cp -a /workspace/.gc /city-stage/.gc 2>/dev/null || true' 2>/dev/null || true
      fi

      # Signal init container to exit — all files are in place.
      "${KUBECTL[@]}" exec "$pod" -c stage -- touch /workspace/.gc-ready 2>/dev/null || \
        echo "start: warning: failed to signal init container" >&2
    fi

    # Wait for pod (main container) to reach Running/Ready.
    if ! "${KUBECTL[@]}" wait --for=condition=Ready "pod/$pod" --timeout=120s >/dev/null 2>&1; then
      phase=$("${KUBECTL[@]}" get pod "$pod" -o jsonpath='{.status.phase}' 2>/dev/null || true)
      case "$phase" in
        Running|Succeeded)
          ;; # Ready condition may not fire, but it's running.
        Failed)
          echo "start: pod $pod failed to start" >&2
          exit 1
          ;;
        *)
          echo "start: pod $pod not ready after 120s (phase: ${phase:-unknown})" >&2
          exit 1
          ;;
      esac
    fi

    # Initialize the city inside the agent pod. Copy the controller's city
    # directory as a source, then run gc init --from to create .gc/, .beads/,
    # settings.json, etc. This gives each agent a fully configured workspace
    # with bd pointing at the in-cluster dolt server.
    city_dir=$(echo "$env_json" | jq -r '.GC_CITY // ""')
    if [ -n "$city_dir" ] && [ -d "$city_dir" ]; then
      "${KUBECTL[@]}" exec "$pod" -- mkdir -p /tmp/city-src || true
      # Use tar -h to dereference symlinks (formula files are symlinked from
      # topologies/) and --exclude='.gc' to skip sockets/locks.
      tar chf - -C "$city_dir" --exclude='.gc' . | \
        "${KUBECTL[@]}" exec -i "$pod" -- tar xf - -C /tmp/city-src || \
        echo "start: warning: failed to copy city dir" >&2
      "${KUBECTL[@]}" exec "$pod" -- gc init --from /tmp/city-src /workspace || \
        echo "start: warning: gc init failed" >&2
      "${KUBECTL[@]}" exec "$pod" -- rm -rf /tmp/city-src 2>/dev/null || true
    fi

    # Signal the entrypoint to proceed with tmux creation. The entrypoint
    # waits for this sentinel before starting the agent command, ensuring
    # .beads/, formulas, and settings are all in place.
    "${KUBECTL[@]}" exec "$pod" -- touch /workspace/.gc-workspace-ready 2>/dev/null || true

    # Wait for tmux session to be available inside the pod.
    # The entrypoint creates tmux after .gc-workspace-ready is touched.
    for i in $(seq 1 60); do
      if "${KUBECTL[@]}" exec "$pod" -- tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        break
      fi
      if [ "$i" -eq 60 ]; then
        echo "start: tmux session not ready in pod $pod after 60s" >&2
        exit 1
      fi
      sleep 1
    done

    # Capture pane output to a log file for post-mortem diagnostics.
    # If Claude exits, tmux dies but the pod stays alive (sleep infinity).
    # The log file persists and can be read during stale pod cleanup.
    "${KUBECTL[@]}" exec "$pod" -- \
      tmux pipe-pane -t "$TMUX_SESSION" -o "cat >> /tmp/agent-output.log" 2>/dev/null || true

    # --- Post-readiness setup ---
    # Dialog handling (workspace trust, bypass permissions) is done in Go
    # by exec.Start() via session.AcceptStartupDialogs after this script
    # returns. See internal/session/dialog.go.

    # Run session_setup commands inside the pod.
    # These commands run on the target filesystem (inside the container),
    # not on the controller. Non-fatal: warn on failure, session still works.
    echo "$config" | jq -r '.session_setup // [] | .[]' | while IFS= read -r cmd; do
      [ -z "$cmd" ] && continue
      timeout 10 "${KUBECTL[@]}" exec "$pod" -- sh -c "$cmd" 2>/dev/null || \
        echo "session_setup warning: $cmd" >&2
    done

    # Run session_setup_script inside the pod.
    # The script path is on the controller filesystem — read it locally
    # and execute its contents inside the pod.
    setup_script=$(echo "$config" | jq -r '.session_setup_script // ""')
    if [ -n "$setup_script" ] && [ -f "$setup_script" ]; then
      if ! timeout 10 "${KUBECTL[@]}" exec -i "$pod" -- sh < "$setup_script" >/dev/null 2>&1; then
        echo "session_setup_script warning: script failed in pod $pod" >&2
      fi
    elif [ -n "$setup_script" ]; then
      echo "session_setup_script warning: $setup_script not found on controller" >&2
    fi
    ;;

  stop)
    if [ -z "$name" ]; then
      echo "stop: missing session name" >&2
      exit 1
    fi
    label=$(sanitize_label "$name")
    # Idempotent: no error if pod doesn't exist.
    # Short grace period so stop completes within exec provider timeout (30s).
    "${KUBECTL[@]}" delete pod -l "gc-session=$label" --ignore-not-found --grace-period=5 >/dev/null 2>&1 || true
    ;;

  interrupt)
    if [ -z "$name" ]; then exit 0; fi
    pod=$(get_pod_name_by_label "$name")
    [ -z "$pod" ] && exit 0
    # Send Ctrl-C via tmux (same as local tmux provider).
    "${KUBECTL[@]}" exec "$pod" -- tmux send-keys -t "$TMUX_SESSION" C-c 2>/dev/null || true
    ;;

  is-running)
    if [ -z "$name" ]; then
      echo "false"
      exit 0
    fi
    label=$(sanitize_label "$name")
    pod=$("${KUBECTL[@]}" get pods -l "gc-session=$label" \
      --field-selector=status.phase=Running \
      -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
    # Pod must be Running AND tmux session alive. If Claude exits, tmux
    # dies but sleep infinity keeps the pod alive — that's not "running".
    if [ -n "$pod" ] && \
       "${KUBECTL[@]}" exec "$pod" -- tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
      echo "true"
    else
      echo "false"
    fi
    ;;

  attach)
    if [ -z "$name" ]; then
      echo "attach: missing session name" >&2
      exit 1
    fi
    pod=$(get_pod_name_by_label "$name")
    if [ -z "$pod" ]; then
      echo "attach: no running pod for session \"$name\"" >&2
      exit 1
    fi
    # Attach to the tmux session inside the pod.
    exec "${KUBECTL[@]}" exec -it "$pod" -- tmux attach -t "$TMUX_SESSION"
    ;;

  process-alive)
    # Read process names from stdin (one per line).
    if [ -z "$name" ]; then
      echo "true"
      exit 0
    fi
    process_names=()
    while IFS= read -r pname || [ -n "$pname" ]; do
      [ -n "$pname" ] && process_names+=("$pname")
    done
    if [ ${#process_names[@]} -eq 0 ]; then
      echo "true"
      exit 0
    fi
    pod=$(get_pod_name_by_label "$name")
    if [ -z "$pod" ]; then
      echo "false"
      exit 0
    fi
    # Pod phase stays "Running" during graceful shutdown; check
    # deletionTimestamp to detect terminating pods.
    delts=$("${KUBECTL[@]}" get pod "$pod" -o jsonpath='{.metadata.deletionTimestamp}' 2>/dev/null) || true
    if [ -n "$delts" ]; then
      echo "false"
      exit 0
    fi
    for pname in "${process_names[@]}"; do
      if "${KUBECTL[@]}" exec "$pod" -- pgrep -f "$pname" >/dev/null 2>&1; then
        echo "true"
        exit 0
      fi
    done
    echo "false"
    ;;

  nudge)
    if [ -z "$name" ]; then
      cat > /dev/null
      exit 0
    fi
    msg=$(cat)
    pod=$(get_pod_name_by_label "$name")
    [ -z "$pod" ] && exit 0
    # Type the message into the tmux session followed by Enter.
    "${KUBECTL[@]}" exec "$pod" -- tmux send-keys -t "$TMUX_SESSION" "$msg" Enter 2>/dev/null || true
    ;;

  send-keys)
    # Send bare tmux keystrokes (e.g., Enter, Down, C-c) to the session.
    # Args after name are passed directly to tmux send-keys.
    if [ -z "$name" ]; then exit 0; fi
    pod=$(get_pod_name_by_label "$name")
    [ -z "$pod" ] && exit 0
    shift 2  # skip op and name, rest are keys
    "${KUBECTL[@]}" exec "$pod" -- tmux send-keys -t "$TMUX_SESSION" "$@" 2>/dev/null || true
    ;;

  set-meta)
    # Store in tmux environment inside the pod. This is the same store
    # the agent's default tmux provider reads, so both controller (via
    # this script) and agent (via gc agent drain-check) see the same
    # metadata.
    key="${3:?set-meta: missing key}"
    value=$(cat)
    if [ -z "$name" ]; then exit 0; fi
    pod=$(get_any_pod_by_label "$name")
    [ -z "$pod" ] && exit 0
    "${KUBECTL[@]}" exec "$pod" -- \
      tmux set-environment -t "$TMUX_SESSION" "$key" "$value" 2>/dev/null || true
    ;;

  get-meta)
    # Read from tmux environment inside the pod.
    # Output format: KEY=VALUE (set), -KEY (unset), or error (never set).
    key="${3:?get-meta: missing key}"
    if [ -z "$name" ]; then exit 0; fi
    pod=$(get_any_pod_by_label "$name")
    [ -z "$pod" ] && exit 0
    output=$("${KUBECTL[@]}" exec "$pod" -- \
      tmux show-environment -t "$TMUX_SESSION" "$key" 2>/dev/null) || exit 0
    case "$output" in
      -*) ;; # explicitly unset — return empty
      *=*) printf '%s' "${output#*=}" ;;
    esac
    ;;

  remove-meta)
    key="${3:?remove-meta: missing key}"
    if [ -z "$name" ]; then exit 0; fi
    pod=$(get_any_pod_by_label "$name")
    [ -z "$pod" ] && exit 0
    "${KUBECTL[@]}" exec "$pod" -- \
      tmux set-environment -t "$TMUX_SESSION" -u "$key" 2>/dev/null || true
    ;;

  peek)
    lines="${3:-50}"
    if [ -z "$name" ]; then exit 0; fi
    pod=$(get_pod_name_by_label "$name")
    [ -z "$pod" ] && exit 0
    # Capture tmux pane content — real terminal scrollback, not container logs.
    if [ "$lines" -gt 0 ] 2>/dev/null; then
      "${KUBECTL[@]}" exec "$pod" -- \
        tmux capture-pane -t "$TMUX_SESSION" -p -S "-${lines}" 2>/dev/null || true
    else
      "${KUBECTL[@]}" exec "$pod" -- \
        tmux capture-pane -t "$TMUX_SESSION" -p -S - 2>/dev/null || true
    fi
    ;;

  list-running)
    prefix="${name:-}"
    # List all running gc-agent pods, return unsanitized session names.
    # Prefer the gc-session-name annotation (raw name); fall back to the
    # gc-session label (sanitized) for backward compat with older pods.
    "${KUBECTL[@]}" get pods -l app=gc-agent \
      --field-selector=status.phase=Running \
      -o json 2>/dev/null \
      | jq -r '.items[] |
          (.metadata.annotations["gc-session-name"] // .metadata.labels["gc-session"] // empty)' \
      | while IFS= read -r sess; do
          [ -z "$sess" ] && continue
          if [ -z "$prefix" ] || [[ "$sess" == "$prefix"* ]]; then
            echo "$sess"
          fi
        done
    exit 0
    ;;

  get-last-activity)
    if [ -z "$name" ]; then exit 0; fi
    pod=$(get_pod_name_by_label "$name")
    [ -z "$pod" ] && exit 0
    # Query tmux for the session's last activity (unix timestamp).
    epoch=$("${KUBECTL[@]}" exec "$pod" -- \
      tmux display-message -t "$TMUX_SESSION" -p '#{session_activity}' 2>/dev/null) || exit 0
    epoch=$(echo "$epoch" | tr -d '[:space:]')
    [ -z "$epoch" ] && exit 0
    # Convert unix timestamp to RFC3339.
    date -u -d "@${epoch}" '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || true
    ;;

  clear-scrollback)
    if [ -z "$name" ]; then exit 0; fi
    pod=$(get_pod_name_by_label "$name")
    [ -z "$pod" ] && exit 0
    # Clear the tmux scrollback buffer.
    "${KUBECTL[@]}" exec "$pod" -- \
      tmux clear-history -t "$TMUX_SESSION" 2>/dev/null || true
    ;;

  copy-to)
    # Copy a file or directory into the named session's /workspace.
    # Usage: script copy-to <name> <src> <rel_dst>
    src="${3:-}"
    rel_dst="${4:-}"
    if [ -z "$name" ] || [ -z "$src" ]; then exit 0; fi
    pod=$(get_pod_name_by_label "$name")
    [ -z "$pod" ] && exit 0
    dst="/workspace"
    [ -n "$rel_dst" ] && dst="/workspace/$rel_dst"
    "${KUBECTL[@]}" exec "$pod" -- mkdir -p "$dst" 2>/dev/null || true
    if [ -d "$src" ]; then
      "${KUBECTL[@]}" cp "$src/." "$pod:$dst/" 2>/dev/null || true
    elif [ -f "$src" ]; then
      "${KUBECTL[@]}" cp "$src" "$pod:$dst" 2>/dev/null || true
    fi
    ;;

  copy-from)
    # Read a file from inside the pod and output its contents on stdout.
    # Usage: script copy-from <name> <path>
    path="${3:-}"
    if [ -z "$name" ] || [ -z "$path" ]; then exit 1; fi
    pod=$(get_pod_name_by_label "$name")
    [ -z "$pod" ] && exit 1
    "${KUBECTL[@]}" exec "$pod" -- cat "$path" 2>/dev/null
    ;;

  *)
    # Unknown operation — exit 2 for forward compatibility.
    exit 2
    ;;
esac
