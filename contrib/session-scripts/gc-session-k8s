#!/usr/bin/env bash
# gc-session-k8s — Kubernetes session provider for Gas City.
#
# Implements the exec session provider protocol, mapping each operation
# to kubectl + tmux commands. Agent sessions run as Kubernetes Pods with
# tmux inside the container providing a real terminal session.
#
# Architecture: the pod's entrypoint starts tmux with the agent command.
# All session operations (nudge, peek, attach, interrupt) delegate to
# tmux inside the pod via kubectl exec. This gives identical semantics
# to the local tmux provider — real terminal scrollback, keystroke
# nudge, interactive attach.
#
# See docs/exec-session-protocol.md for the full protocol specification.
#
# Dependencies: kubectl, jq, bash
# Container requirements: tmux, bash
#
# Usage: GC_SESSION=exec:/path/to/gc-session-k8s gc start <city>
#
# Configuration via environment variables:
#
#   GC_K8S_NAMESPACE   - K8s namespace for agent pods (default: gc)
#   GC_K8S_IMAGE       - Container image for agents (required for start)
#   GC_K8S_CONTEXT     - kubectl context (default: current)
#   GC_K8S_DOLT_HOST   - Dolt service DNS (default: dolt.gc.svc.cluster.local)
#   GC_K8S_DOLT_PORT   - Dolt service port (default: 3307)
#   GC_K8S_CPU_REQUEST - Pod CPU request (default: 500m)
#   GC_K8S_MEM_REQUEST - Pod memory request (default: 1Gi)
#   GC_K8S_CPU_LIMIT   - Pod CPU limit (default: 2)
#   GC_K8S_MEM_LIMIT   - Pod memory limit (default: 4Gi)

set -euo pipefail

op="${1:?missing operation}"
name="${2:-}"

# Tmux session name inside each pod (constant — one session per pod).
TMUX_SESSION="main"

# --- Configuration ---

NS="${GC_K8S_NAMESPACE:-gc}"
IMAGE="${GC_K8S_IMAGE:-}"
DOLT_HOST="${GC_K8S_DOLT_HOST:-dolt.gc.svc.cluster.local}"
DOLT_PORT="${GC_K8S_DOLT_PORT:-3307}"
CPU_REQ="${GC_K8S_CPU_REQUEST:-500m}"
MEM_REQ="${GC_K8S_MEM_REQUEST:-1Gi}"
CPU_LIM="${GC_K8S_CPU_LIMIT:-2}"
MEM_LIM="${GC_K8S_MEM_LIMIT:-4Gi}"

# Build kubectl base command with optional context.
KUBECTL=(kubectl)
if [ -n "${GC_K8S_CONTEXT:-}" ]; then
  KUBECTL+=(--context "$GC_K8S_CONTEXT")
fi
KUBECTL+=(-n "$NS")

# --- Helpers ---

# sanitize_name converts a session name to a valid K8s resource name.
# K8s names: lowercase, alphanumeric, '-', max 63 chars, must start/end
# with alphanumeric.
sanitize_name() {
  echo "$1" \
    | tr '[:upper:]' '[:lower:]' \
    | sed 's/[^a-z0-9-]/-/g' \
    | sed 's/^-*//' \
    | sed 's/-*$//' \
    | cut -c1-63 \
    | sed 's/-*$//'
}

# sanitize_label converts a value to a valid K8s label value.
# Label values: alphanumeric, '-', '_', '.', max 63 chars, must start/end
# with alphanumeric. Empty is also valid.
sanitize_label() {
  local v
  v=$(echo "$1" \
    | sed 's/[^a-zA-Z0-9._-]/-/g' \
    | sed 's/^[^a-zA-Z0-9]*//' \
    | sed 's/[^a-zA-Z0-9]*$//' \
    | cut -c1-63 \
    | sed 's/[^a-zA-Z0-9]*$//')
  echo "${v:-unknown}"
}

# pod_name returns the pod name for a session.
pod_name() {
  sanitize_name "$1"
}

# get_pod_name_by_label finds a pod by gc-session label, returns first match.
get_pod_name_by_label() {
  local label
  label=$(sanitize_label "$1")
  "${KUBECTL[@]}" get pods -l "gc-session=$label" \
    --field-selector=status.phase=Running \
    -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true
}

# get_any_pod_by_label finds a pod by gc-session label (any phase).
get_any_pod_by_label() {
  local label
  label=$(sanitize_label "$1")
  "${KUBECTL[@]}" get pods -l "gc-session=$label" \
    -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true
}

# --- Operations ---

case "$op" in
  start)
    # Read JSON config from stdin.
    config=$(cat)
    command=$(echo "$config" | jq -r '.command // ""')
    env_json=$(echo "$config" | jq -c '.env // {}')

    if [ -z "$name" ]; then
      echo "start: missing session name" >&2
      exit 1
    fi
    if [ -z "$IMAGE" ]; then
      echo "start: GC_K8S_IMAGE is required" >&2
      exit 1
    fi

    pod=$(pod_name "$name")
    label=$(sanitize_label "$name")

    # Check if pod already exists.
    existing=$(get_any_pod_by_label "$label")
    if [ -n "$existing" ]; then
      echo "session \"$name\" already exists (pod: $existing)" >&2
      exit 1
    fi

    # Extract agent name from env for labeling.
    gc_agent=$(echo "$env_json" | jq -r '.GC_AGENT // "unknown"')
    gc_agent_label=$(sanitize_label "$gc_agent")

    # Remap command: rewrite --settings paths for container filesystem.
    container_cmd="$command"
    if [ -n "$container_cmd" ]; then
      container_cmd=$(echo "$container_cmd" | sed 's|--settings [^ ]*|--settings /workspace/.gc/settings.json|g')
    fi

    # Pod entrypoint: start tmux with the agent command inside it.
    # tmux provides a real terminal session — nudge, peek, attach all
    # work via tmux commands through kubectl exec.
    # The tail -f /dev/null keeps the container alive if tmux exits.
    tmux_cmd="tmux new-session -d -s ${TMUX_SESSION} '${container_cmd:-/bin/bash}' && tail -f /dev/null"

    # Build the pod manifest as JSON using jq.
    # All values are properly JSON-escaped by jq — no injection risk.
    env_array=$(echo "$env_json" | jq --arg dolt_host "$DOLT_HOST" --arg dolt_port "$DOLT_PORT" '
      del(.GC_DOLT_HOST, .GC_DOLT_PORT)
      | to_entries
      | map({name: .key, value: (.value | tostring)})
      + [{name: "GC_DOLT_HOST", value: $dolt_host},
         {name: "GC_DOLT_PORT", value: $dolt_port}]
    ')

    manifest=$(jq -n \
      --arg pod "$pod" \
      --arg ns "$NS" \
      --arg label "$label" \
      --arg gc_agent_label "$gc_agent_label" \
      --arg image "$IMAGE" \
      --arg cmd "$tmux_cmd" \
      --arg cpu_req "$CPU_REQ" \
      --arg mem_req "$MEM_REQ" \
      --arg cpu_lim "$CPU_LIM" \
      --arg mem_lim "$MEM_LIM" \
      --argjson env "$env_array" \
      '{
        apiVersion: "v1",
        kind: "Pod",
        metadata: {
          name: $pod,
          namespace: $ns,
          labels: {
            app: "gc-agent",
            "gc-session": $label,
            "gc-agent": $gc_agent_label
          }
        },
        spec: {
          restartPolicy: "Never",
          containers: [{
            name: "agent",
            image: $image,
            workingDir: "/workspace",
            command: ["/bin/sh", "-c"],
            args: [$cmd],
            env: $env,
            stdin: true,
            tty: true,
            resources: {
              requests: {cpu: $cpu_req, memory: $mem_req},
              limits: {cpu: $cpu_lim, memory: $mem_lim}
            }
          }]
        }
      }')

    echo "$manifest" | "${KUBECTL[@]}" apply -f - >/dev/null

    # Wait for pod to reach Running. Without this, gc calls is-running
    # immediately and gets false negatives during image pull / scheduling.
    if ! "${KUBECTL[@]}" wait --for=condition=Ready "pod/$pod" --timeout=120s >/dev/null 2>&1; then
      phase=$("${KUBECTL[@]}" get pod "$pod" -o jsonpath='{.status.phase}' 2>/dev/null || true)
      case "$phase" in
        Running|Succeeded)
          ;; # Ready condition may not fire, but it's running.
        Failed)
          echo "start: pod $pod failed to start" >&2
          exit 1
          ;;
        *)
          echo "start: pod $pod not ready after 120s (phase: ${phase:-unknown})" >&2
          exit 1
          ;;
      esac
    fi
    ;;

  stop)
    if [ -z "$name" ]; then
      echo "stop: missing session name" >&2
      exit 1
    fi
    label=$(sanitize_label "$name")
    # Idempotent: no error if pod doesn't exist.
    "${KUBECTL[@]}" delete pod -l "gc-session=$label" --ignore-not-found >/dev/null 2>&1 || true
    ;;

  interrupt)
    if [ -z "$name" ]; then exit 0; fi
    pod=$(get_pod_name_by_label "$name")
    [ -z "$pod" ] && exit 0
    # Send Ctrl-C via tmux (same as local tmux provider).
    "${KUBECTL[@]}" exec "$pod" -- tmux send-keys -t "$TMUX_SESSION" C-c 2>/dev/null || true
    ;;

  is-running)
    if [ -z "$name" ]; then
      echo "false"
      exit 0
    fi
    label=$(sanitize_label "$name")
    phase=$("${KUBECTL[@]}" get pods -l "gc-session=$label" \
      -o jsonpath='{.items[0].status.phase}' 2>/dev/null || true)
    if [ "$phase" = "Running" ]; then
      echo "true"
    else
      echo "false"
    fi
    ;;

  attach)
    if [ -z "$name" ]; then
      echo "attach: missing session name" >&2
      exit 1
    fi
    pod=$(get_pod_name_by_label "$name")
    if [ -z "$pod" ]; then
      echo "attach: no running pod for session \"$name\"" >&2
      exit 1
    fi
    # Attach to the tmux session inside the pod.
    exec "${KUBECTL[@]}" exec -it "$pod" -- tmux attach -t "$TMUX_SESSION"
    ;;

  process-alive)
    # Read process names from stdin (one per line).
    if [ -z "$name" ]; then
      echo "true"
      exit 0
    fi
    process_names=()
    while IFS= read -r pname; do
      [ -n "$pname" ] && process_names+=("$pname")
    done
    if [ ${#process_names[@]} -eq 0 ]; then
      echo "true"
      exit 0
    fi
    pod=$(get_pod_name_by_label "$name")
    if [ -z "$pod" ]; then
      echo "false"
      exit 0
    fi
    for pname in "${process_names[@]}"; do
      if "${KUBECTL[@]}" exec "$pod" -- pgrep -f "$pname" >/dev/null 2>&1; then
        echo "true"
        exit 0
      fi
    done
    echo "false"
    ;;

  nudge)
    if [ -z "$name" ]; then
      cat > /dev/null
      exit 0
    fi
    msg=$(cat)
    pod=$(get_pod_name_by_label "$name")
    [ -z "$pod" ] && exit 0
    # Type the message into the tmux session followed by Enter.
    "${KUBECTL[@]}" exec "$pod" -- tmux send-keys -t "$TMUX_SESSION" "$msg" Enter 2>/dev/null || true
    ;;

  set-meta)
    key="${3:?set-meta: missing key}"
    value=$(cat)
    if [ -z "$name" ]; then exit 0; fi
    pod=$(get_any_pod_by_label "$name")
    [ -z "$pod" ] && exit 0
    "${KUBECTL[@]}" annotate pod "$pod" "gc-meta-${key}=${value}" --overwrite >/dev/null 2>&1 || true
    ;;

  get-meta)
    key="${3:?get-meta: missing key}"
    if [ -z "$name" ]; then exit 0; fi
    pod=$(get_any_pod_by_label "$name")
    [ -z "$pod" ] && exit 0
    "${KUBECTL[@]}" get pod "$pod" \
      -o jsonpath="{.metadata.annotations.gc-meta-${key}}" 2>/dev/null || true
    ;;

  remove-meta)
    key="${3:?remove-meta: missing key}"
    if [ -z "$name" ]; then exit 0; fi
    pod=$(get_any_pod_by_label "$name")
    [ -z "$pod" ] && exit 0
    "${KUBECTL[@]}" annotate pod "$pod" "gc-meta-${key}-" >/dev/null 2>&1 || true
    ;;

  peek)
    lines="${3:-50}"
    if [ -z "$name" ]; then exit 0; fi
    pod=$(get_pod_name_by_label "$name")
    [ -z "$pod" ] && exit 0
    # Capture tmux pane content — real terminal scrollback, not container logs.
    if [ "$lines" -gt 0 ] 2>/dev/null; then
      "${KUBECTL[@]}" exec "$pod" -- \
        tmux capture-pane -t "$TMUX_SESSION" -p -S "-${lines}" 2>/dev/null || true
    else
      "${KUBECTL[@]}" exec "$pod" -- \
        tmux capture-pane -t "$TMUX_SESSION" -p -S - 2>/dev/null || true
    fi
    ;;

  list-running)
    prefix="${name:-}"
    # List all running gc-agent pods, extract gc-session labels.
    "${KUBECTL[@]}" get pods -l app=gc-agent \
      --field-selector=status.phase=Running \
      -o jsonpath='{range .items[*]}{.metadata.labels.gc-session}{"\n"}{end}' 2>/dev/null \
      | while IFS= read -r sess; do
          [ -z "$sess" ] && continue
          if [ -z "$prefix" ] || [[ "$sess" == "$prefix"* ]]; then
            echo "$sess"
          fi
        done
    exit 0
    ;;

  get-last-activity)
    # Empty stdout = unsupported (per protocol).
    ;;

  clear-scrollback)
    if [ -z "$name" ]; then exit 0; fi
    pod=$(get_pod_name_by_label "$name")
    [ -z "$pod" ] && exit 0
    # Clear the tmux scrollback buffer.
    "${KUBECTL[@]}" exec "$pod" -- \
      tmux clear-history -t "$TMUX_SESSION" 2>/dev/null || true
    ;;

  *)
    # Unknown operation — exit 2 for forward compatibility.
    exit 2
    ;;
esac
