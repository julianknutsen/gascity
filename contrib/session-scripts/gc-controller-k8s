#!/usr/bin/env bash
# gc-controller-k8s — Deploy and manage the Gas City controller on Kubernetes.
#
# The controller runs gc start --foreground inside a pod, continuously
# reconciling agent sessions. Agent pods are managed via the native K8s
# session provider (GC_SESSION=k8s) using client-go.
#
# Operations:
#   deploy <city-path>  — Create controller pod, copy city dir, verify start
#   stop                — Delete controller pod (graceful shutdown)
#   status              — Show pod phase and age
#   logs [--follow]     — Tail controller output
#
# Configuration via environment variables:
#   GC_K8S_NAMESPACE          — K8s namespace (default: gc)
#   GC_K8S_CONTROLLER_IMAGE   — Controller image (default: gc-controller:latest)
#   GC_K8S_CONTEXT            — kubectl context (default: current)
#   GC_K8S_IMAGE              — Agent image (passed to controller env)
#
# Prerequisites:
#   - kubectl configured with cluster access
#   - Controller RBAC applied: kubectl apply -f contrib/k8s/controller-rbac.yaml
#   - Controller image built: docker build -f contrib/k8s/Dockerfile.controller ...
#
# Usage:
#   contrib/session-scripts/gc-controller-k8s deploy examples/gastown/
#   contrib/session-scripts/gc-controller-k8s logs --follow
#   contrib/session-scripts/gc-controller-k8s stop

set -euo pipefail

op="${1:?Usage: gc-controller-k8s <deploy|stop|status|logs> [args...]}"
shift || true

# --- Configuration ---

NS="${GC_K8S_NAMESPACE:-gc}"
CTRL_IMAGE="${GC_K8S_CONTROLLER_IMAGE:-gc-controller:latest}"
AGENT_IMAGE="${GC_K8S_IMAGE:-gc-agent:latest}"
DOLT_HOST="${GC_K8S_DOLT_HOST:-dolt.gc.svc.cluster.local}"
DOLT_PORT="${GC_K8S_DOLT_PORT:-3307}"
POD_NAME="gc-controller"
SA_NAME="gc-controller"

# Controller pod resource overrides (same pattern as gc-session-k8s).
CTRL_CPU_REQ="${GC_K8S_CTRL_CPU_REQUEST:-100m}"
CTRL_MEM_REQ="${GC_K8S_CTRL_MEM_REQUEST:-256Mi}"
CTRL_CPU_LIM="${GC_K8S_CTRL_CPU_LIMIT:-500m}"
CTRL_MEM_LIM="${GC_K8S_CTRL_MEM_LIMIT:-512Mi}"

# Build kubectl base command with optional context.
KUBECTL=(kubectl)
if [ -n "${GC_K8S_CONTEXT:-}" ]; then
  KUBECTL+=(--context "$GC_K8S_CONTEXT")
fi
KUBECTL+=(-n "$NS")

# --- Operations ---

CLAUDE_DIR="${CLAUDE_DIR:-$HOME/.claude}"

# sync_creds compares local Claude credentials with the K8s secret and
# updates the secret if they differ. Called during deploy and available
# as a standalone operation.
sync_creds() {
  local cred_file="$CLAUDE_DIR/.credentials.json"
  if [ ! -f "$cred_file" ]; then
    echo "sync-creds: no local credentials at $cred_file" >&2
    return 0
  fi

  # Build --from-file args from available credential files.
  local args=()
  for f in .credentials.json settings.json .claude.json; do
    [ -f "$CLAUDE_DIR/$f" ] && args+=(--from-file="$f=$CLAUDE_DIR/$f")
  done

  # Compare local token with K8s secret token.
  local local_token k8s_token
  local_token=$(jq -r '.claudeAiOauth.accessToken // ""' "$cred_file" 2>/dev/null)
  k8s_token=$("${KUBECTL[@]}" get secret claude-credentials \
    -o jsonpath='{.data.\.credentials\.json}' 2>/dev/null | base64 -d 2>/dev/null | \
    jq -r '.claudeAiOauth.accessToken // ""' 2>/dev/null)

  if [ "$local_token" = "$k8s_token" ] && [ -n "$local_token" ]; then
    return 0  # Already in sync.
  fi

  echo "Syncing Claude credentials to K8s secret..."
  "${KUBECTL[@]}" create secret generic claude-credentials \
    "${args[@]}" --dry-run=client -o yaml | "${KUBECTL[@]}" apply -f - >/dev/null
}

# derive_prefix replicates config.DeriveBeadsPrefix in bash.
# Algorithm: strip -py/-go suffix, split on hyphens.
# 2+ parts → first letter of each; 1 part ≤3 chars → as-is; else first 2.
derive_prefix() {
  local name="$1"
  name="${name%-py}"
  name="${name%-go}"
  IFS='-' read -ra parts <<< "$name"
  if [ "${#parts[@]}" -ge 2 ]; then
    local prefix=""
    for p in "${parts[@]}"; do
      prefix+="${p:0:1}"
    done
    echo "$prefix"
  elif [ "${#name}" -le 3 ]; then
    echo "$name"
  else
    echo "${name:0:2}"
  fi
}

# init_controller_beads initializes bd databases on the controller pod so
# scale_check commands can query beads via the dolt server directly.
# Local tmux/docker deploys don't need this — bd uses local .beads/ dirs.
# Parses city.toml from the HOST side to find workspace name and rig info.
init_controller_beads() {
  local city_toml="$1"

  # Parse workspace name.
  local ws_name
  ws_name=$(sed -n '/^\[workspace\]/,/^\[/{ s/^name *= *"\([^"]*\)".*/\1/p; }' "$city_toml" | head -1)
  if [ -z "$ws_name" ]; then
    ws_name=$(basename "$(dirname "$city_toml")")
  fi

  # Init HQ beads on controller.
  local hq_prefix
  hq_prefix=$(derive_prefix "$ws_name")
  echo "  HQ (prefix: $hq_prefix)..."
  "${KUBECTL[@]}" exec "$POD_NAME" -- sh -c \
    "cd /city && bd init --server --server-host '$DOLT_HOST' --server-port '$DOLT_PORT' -p '$hq_prefix' --skip-hooks" \
    >/dev/null 2>&1 || true

  # Parse [[rigs]] and init each rig's beads on the controller.
  local in_rig=false rig_name="" rig_path="" rig_prefix=""
  flush_rig() {
    [ -z "$rig_name" ] && return
    [ -z "$rig_path" ] && rig_path="$rig_name"
    [ -z "$rig_prefix" ] && rig_prefix=$(derive_prefix "$rig_name")
    echo "  rig '$rig_name' (prefix: $rig_prefix)..."
    "${KUBECTL[@]}" exec "$POD_NAME" -- sh -c \
      "mkdir -p '/city/$rig_path' && cd '/city/$rig_path' && \
       bd init --server --server-host '$DOLT_HOST' --server-port '$DOLT_PORT' -p '$rig_prefix' --skip-hooks" \
      >/dev/null 2>&1 || true
    rig_name="" rig_path="" rig_prefix=""
  }

  while IFS= read -r line; do
    line=$(echo "$line" | sed 's/^[[:space:]]*//')
    if [ "$line" = "[[rigs]]" ]; then
      flush_rig
      in_rig=true
      continue
    fi
    # New section header ends current rig block.
    case "$line" in
      "["*)
        if $in_rig; then flush_rig; in_rig=false; fi
        ;;
    esac
    if $in_rig; then
      case "$line" in
        name\ =*|name=*) rig_name=$(echo "$line" | sed 's/.*= *"\([^"]*\)".*/\1/') ;;
        path\ =*|path=*) rig_path=$(echo "$line" | sed 's/.*= *"\([^"]*\)".*/\1/') ;;
        beads_prefix\ =*|beads_prefix=*) rig_prefix=$(echo "$line" | sed 's/.*= *"\([^"]*\)".*/\1/') ;;
      esac
    fi
  done < "$city_toml"
  flush_rig  # Flush last rig if file ends without another section.
}

case "$op" in
  sync-creds)
    sync_creds
    ;;

  deploy)
    city_path="${1:?deploy: missing city-path argument}"

    # Resolve to absolute path.
    city_path=$(cd "$city_path" && pwd)

    if [ ! -f "$city_path/city.toml" ]; then
      echo "deploy: $city_path/city.toml not found" >&2
      exit 1
    fi

    # Sync credentials before deploying.
    sync_creds

    # Clean up any existing controller pod.
    "${KUBECTL[@]}" delete pod "$POD_NAME" --ignore-not-found >/dev/null 2>&1 || true
    "${KUBECTL[@]}" wait --for=delete "pod/$POD_NAME" --timeout=30s >/dev/null 2>&1 || true

    # Create controller pod.
    manifest=$(jq -n \
      --arg pod "$POD_NAME" \
      --arg ns "$NS" \
      --arg image "$CTRL_IMAGE" \
      --arg agent_image "$AGENT_IMAGE" \
      --arg sa "$SA_NAME" \
      --arg cpu_req "$CTRL_CPU_REQ" \
      --arg mem_req "$CTRL_MEM_REQ" \
      --arg cpu_lim "$CTRL_CPU_LIM" \
      --arg mem_lim "$CTRL_MEM_LIM" \
      --arg prebaked "${GC_K8S_PREBAKED:-false}" \
      '{
        apiVersion: "v1",
        kind: "Pod",
        metadata: {
          name: $pod,
          namespace: $ns,
          labels: {
            app: "gc-controller"
          }
        },
        spec: {
          serviceAccountName: $sa,
          restartPolicy: "Never",
          containers: [{
            name: "controller",
            image: $image,
            imagePullPolicy: "IfNotPresent",
            workingDir: "/city",
            env: [
              {name: "GC_SESSION", value: "k8s"},
              {name: "GC_BEADS", value: "exec:gc-beads-k8s"},
              {name: "GC_EVENTS", value: "exec:gc-events-k8s"},
              {name: "GC_K8S_IMAGE", value: $agent_image},
              {name: "GC_K8S_NAMESPACE", value: $ns},
              {name: "GC_K8S_PREBAKED", value: $prebaked},
              {name: "GC_K8S_MCP_MAIL_HOST", value: "mcp-mail.gc.svc.cluster.local"},
              {name: "GC_K8S_MCP_MAIL_PORT", value: "8765"}
            ],
            resources: {
              requests: {cpu: $cpu_req, memory: $mem_req},
              limits: {cpu: $cpu_lim, memory: $mem_lim}
            },
            volumeMounts: [{name: "city", mountPath: "/city"}]
          }],
          volumes: [{
            name: "city",
            emptyDir: {}
          }]
        }
      }')

    echo "$manifest" | "${KUBECTL[@]}" apply -f - >/dev/null

    # Wait for container to be running (not yet Ready — it's waiting for city.toml).
    echo "Waiting for controller pod..."
    for i in $(seq 1 60); do
      phase=$("${KUBECTL[@]}" get pod "$POD_NAME" \
        -o jsonpath='{.status.containerStatuses[0].state.running}' 2>/dev/null || true)
      [ -n "$phase" ] && break
      if [ "$i" -eq 60 ]; then
        echo "deploy: controller pod not running after 60s" >&2
        exit 1
      fi
      sleep 1
    done

    # Copy city directory into the controller pod.
    echo "Copying city directory..."
    "${KUBECTL[@]}" cp "$city_path/." "$POD_NAME:/city/" || {
      echo "deploy: failed to copy city directory" >&2
      exit 1
    }

    # Wait for gc init to complete (sentinel written by Dockerfile CMD).
    echo "Waiting for gc init..."
    for i in $(seq 1 60); do
      if "${KUBECTL[@]}" exec "$POD_NAME" -- test -f /city/.gc-init-done 2>/dev/null; then
        break
      fi
      if [ "$i" -eq 60 ]; then
        echo "deploy: gc init did not complete after 60s" >&2
        exit 1
      fi
      sleep 1
    done

    # Initialize bd databases on the controller pod so scale_check commands
    # can query beads via the dolt server. This is K8s-specific — local
    # tmux/docker deploys don't need it (bd uses local .beads/ dirs).
    echo "Initializing beads on controller..."
    init_controller_beads "$city_path/city.toml"

    # Signal gc start to begin.
    "${KUBECTL[@]}" exec "$POD_NAME" -- touch /city/.gc-start

    # Wait for controller to start (gc start enters reconcile loop).
    echo "Waiting for controller startup..."
    for i in $(seq 1 30); do
      logs=$("${KUBECTL[@]}" logs "$POD_NAME" --tail=5 2>/dev/null || true)
      if echo "$logs" | grep -q "City started\.\|reconcil"; then
        echo "Controller deployed successfully."
        exit 0
      fi
      sleep 2
    done
    echo "Controller pod is running (check logs for startup status)."
    ;;

  stop)
    "${KUBECTL[@]}" delete pod "$POD_NAME" --ignore-not-found >/dev/null 2>&1 || true
    echo "Controller stopped."
    ;;

  status)
    phase=$("${KUBECTL[@]}" get pod "$POD_NAME" \
      -o jsonpath='{.status.phase}' 2>/dev/null || true)
    if [ -z "$phase" ]; then
      echo "Controller pod not found."
      exit 1
    fi
    age=$("${KUBECTL[@]}" get pod "$POD_NAME" \
      -o jsonpath='{.metadata.creationTimestamp}' 2>/dev/null || true)
    echo "Phase: $phase"
    echo "Created: $age"
    ;;

  logs)
    follow_flag=""
    if [ "${1:-}" = "--follow" ] || [ "${1:-}" = "-f" ]; then
      follow_flag="-f"
    fi
    # shellcheck disable=SC2086
    "${KUBECTL[@]}" logs "$POD_NAME" $follow_flag
    ;;

  *)
    echo "Usage: gc-controller-k8s <deploy|stop|status|logs> [args...]" >&2
    exit 1
    ;;
esac
