#!/usr/bin/env bash
# gc-mail-mcp-agent-mail — Gas City exec mail provider bridging to mcp_agent_mail.
#
# Delegates Gas City mail operations to mcp_agent_mail's HTTP MCP API
# (https://github.com/Dicklesworthstone/mcp_agent_mail) via curl + jq.
#
# Usage:
#   export GC_MAIL=exec:/path/to/contrib/mail-scripts/gc-mail-mcp-agent-mail
#   gc start my-city
#
# Environment:
#   GC_MCP_MAIL_URL     — mcp_agent_mail server URL (default: http://127.0.0.1:8765)
#   GC_MCP_MAIL_TOKEN   — Bearer token for auth (default: empty)
#   GC_MCP_MAIL_PROJECT — project_key for mcp_agent_mail (default: pwd)
#
# Dependencies: curl, jq, bash
set -euo pipefail

op="${1:?usage: gc-mail-mcp-agent-mail <operation> [args...]}"
shift

# --- Configuration ---

MCP_URL="${GC_MCP_MAIL_URL:-http://127.0.0.1:8765}"
MCP_TOKEN="${GC_MCP_MAIL_TOKEN:-}"
PROJECT="${GC_MCP_MAIL_PROJECT:-$(pwd)}"

# --- Helpers ---

# mcp_call invokes an MCP tool via JSON-RPC and returns the text content.
# Args: tool_name arguments_json
mcp_call() {
  local tool="$1"
  local arguments="$2"
  local auth_header=()
  if [ -n "$MCP_TOKEN" ]; then
    auth_header=(-H "Authorization: Bearer $MCP_TOKEN")
  fi

  local body
  body=$(jq -n --arg tool "$tool" --argjson args "$arguments" '{
    jsonrpc: "2.0",
    id: 1,
    method: "tools/call",
    params: {
      name: $tool,
      arguments: $args
    }
  }')

  local response
  response=$(curl -s -X POST "${MCP_URL}/mcp" \
    -H "Content-Type: application/json" \
    "${auth_header[@]}" \
    -d "$body")

  # Check for JSON-RPC error.
  local error
  error=$(echo "$response" | jq -r '.error // empty')
  if [ -n "$error" ]; then
    echo "mcp_agent_mail error: $error" >&2
    return 1
  fi

  # Extract the text content from the MCP result.
  echo "$response" | jq -r '.result.content[0].text // empty'
}

# ensure_agent registers an agent if not already registered (idempotent).
ensure_agent() {
  local name="$1"
  mcp_call "register_agent" "$(jq -n \
    --arg project "$PROJECT" \
    --arg name "$name" \
    '{project_key: $project, agent_name: $name}')" > /dev/null 2>&1 || true
}

# to_gc_message converts a single mcp_agent_mail message JSON to gc Message format.
# Input: mcp_agent_mail message JSON on stdin.
to_gc_message() {
  jq '{
    id: (.id | tostring),
    from: (.sender.name // .sender_name // "unknown"),
    to: (.recipients[0].name // .recipients[0] // .to // "unknown"),
    body: (.body_md // .body // ""),
    created_at: (.created_ts // .created_at // (now | strftime("%Y-%m-%dT%H:%M:%SZ")))
  }'
}

# to_gc_messages converts an array of mcp_agent_mail messages to gc Message[] format.
to_gc_messages() {
  jq '[.[] | {
    id: (.id | tostring),
    from: (.sender.name // .sender_name // "unknown"),
    to: (.recipients[0].name // .recipients[0] // .to // "unknown"),
    body: (.body_md // .body // ""),
    created_at: (.created_ts // .created_at // (now | strftime("%Y-%m-%dT%H:%M:%SZ")))
  }]'
}

# --- Operations ---

case "$op" in
  ensure-running)
    # Verify server is reachable.
    local_status=$(curl -s -o /dev/null -w "%{http_code}" "${MCP_URL}/health/liveness" 2>/dev/null || echo "000")
    if [ "$local_status" = "000" ]; then
      echo "mcp_agent_mail not reachable at ${MCP_URL}" >&2
      exit 1
    fi

    # Ensure the project exists.
    mcp_call "ensure_project" "$(jq -n --arg project "$PROJECT" \
      '{project_key: $project}')" > /dev/null 2>&1 || true
    ;;

  send)
    to="${1:?usage: gc-mail-mcp-agent-mail send <to>}"
    input=$(cat)
    from=$(echo "$input" | jq -r '.from')
    body=$(echo "$input" | jq -r '.body')

    # Auto-register both sender and recipient.
    ensure_agent "$from"
    ensure_agent "$to"

    result=$(mcp_call "send_message" "$(jq -n \
      --arg project "$PROJECT" \
      --arg from "$from" \
      --arg to "$to" \
      --arg subject "$body" \
      --arg body_md "$body" \
      '{
        project_key: $project,
        sender_name: $from,
        to: [$to],
        subject: $subject,
        body_md: $body_md
      }')")

    echo "$result" | jq '.' | to_gc_message
    ;;

  inbox)
    recipient="${1:?usage: gc-mail-mcp-agent-mail inbox <recipient>}"
    ensure_agent "$recipient"

    result=$(mcp_call "fetch_inbox" "$(jq -n \
      --arg project "$PROJECT" \
      --arg name "$recipient" \
      '{project_key: $project, agent_name: $name}')")

    if [ -z "$result" ] || [ "$result" = "null" ] || [ "$result" = "[]" ]; then
      echo ""
    else
      echo "$result" | jq '.' | to_gc_messages
    fi
    ;;

  check)
    recipient="${1:?usage: gc-mail-mcp-agent-mail check <recipient>}"
    ensure_agent "$recipient"

    result=$(mcp_call "fetch_inbox" "$(jq -n \
      --arg project "$PROJECT" \
      --arg name "$recipient" \
      '{project_key: $project, agent_name: $name}')")

    if [ -z "$result" ] || [ "$result" = "null" ] || [ "$result" = "[]" ]; then
      echo ""
    else
      echo "$result" | jq '.' | to_gc_messages
    fi
    ;;

  read)
    id="${1:?usage: gc-mail-mcp-agent-mail read <id>}"
    if ! printf '%s' "$id" | grep -qE '^[0-9]+$'; then
      echo "invalid message ID: $id" >&2
      exit 1
    fi

    # Acknowledge (mark as read), then re-fetch the message.
    mcp_call "acknowledge_message" "$(jq -n \
      --arg project "$PROJECT" \
      --argjson id "$id" \
      '{project_key: $project, message_id: $id}')" > /dev/null 2>&1 || true

    result=$(mcp_call "get_message" "$(jq -n \
      --arg project "$PROJECT" \
      --argjson id "$id" \
      '{project_key: $project, message_id: $id}')")

    echo "$result" | jq '.' | to_gc_message
    ;;

  archive)
    id="${1:?usage: gc-mail-mcp-agent-mail archive <id>}"
    if ! printf '%s' "$id" | grep -qE '^[0-9]+$'; then
      echo "invalid message ID: $id" >&2
      exit 1
    fi
    mcp_call "acknowledge_message" "$(jq -n \
      --arg project "$PROJECT" \
      --argjson id "$id" \
      '{project_key: $project, message_id: $id}')" > /dev/null
    ;;

  *)
    exit 2  # Unknown operation — forward compatible
    ;;
esac
