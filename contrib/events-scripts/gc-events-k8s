#!/usr/bin/env bash
# gc-events-k8s — Kubernetes events provider for Gas City.
#
# Implements the exec events provider protocol, storing events as
# Kubernetes ConfigMaps. Sequence numbers are tracked in a dedicated
# counter ConfigMap with compare-and-swap updates.
#
# See internal/events/exec/exec.go for the protocol specification.
#
# Dependencies: kubectl, jq, bash
#
# Usage: GC_EVENTS=exec:/path/to/gc-events-k8s gc start <city>
#
# Configuration via environment variables:
#
#   GC_K8S_NAMESPACE   - K8s namespace for event ConfigMaps (default: gc)
#   GC_K8S_CONTEXT     - kubectl context (default: current)

set -euo pipefail

op="${1:?missing operation}"
shift

# --- Configuration ---

NS="${GC_K8S_NAMESPACE:-gc}"

# Build kubectl base command with optional context.
KUBECTL=(kubectl)
if [ -n "${GC_K8S_CONTEXT:-}" ]; then
  KUBECTL+=(--context "$GC_K8S_CONTEXT")
fi
KUBECTL+=(-n "$NS")

# --- Constants ---

SEQ_CM="gc-events-seq"
EVT_PREFIX="gc-evt-"
MANAGED_BY="gascity"
COMPONENT_EVENT="event"
COMPONENT_SEQ="event-seq"
MAX_CAS_RETRIES=3

# --- Helpers ---

# pad_seq zero-pads a sequence number to 10 digits.
pad_seq() {
  printf '%010d' "$1"
}

# cm_name returns the ConfigMap name for a given sequence number.
cm_name() {
  echo "${EVT_PREFIX}$(pad_seq "$1")"
}

# --- Operations ---

case "$op" in
  ensure-running)
    # Idempotent: create seq counter ConfigMap if it doesn't exist.
    if ! "${KUBECTL[@]}" get configmap "$SEQ_CM" >/dev/null 2>&1; then
      "${KUBECTL[@]}" create configmap "$SEQ_CM" \
        --from-literal=seq=0 >/dev/null 2>&1 || true
      "${KUBECTL[@]}" label configmap "$SEQ_CM" \
        "app.kubernetes.io/managed-by=$MANAGED_BY" \
        "gc/component=$COMPONENT_SEQ" \
        --overwrite >/dev/null 2>&1 || true
    fi
    ;;

  record)
    # Read event JSON from stdin.
    event_json=$(cat)

    # Atomic seq increment with CAS retry.
    retries=0
    while true; do
      # GET current seq + resourceVersion.
      cm_json=$("${KUBECTL[@]}" get configmap "$SEQ_CM" -o json 2>&1) || {
        echo "record: failed to get seq configmap: $cm_json" >&2
        exit 1
      }
      cur_seq=$(echo "$cm_json" | jq -r '.data.seq')
      rv=$(echo "$cm_json" | jq -r '.metadata.resourceVersion')
      new_seq=$((cur_seq + 1))

      # REPLACE with new seq, using resourceVersion for CAS.
      update_json=$(echo "$cm_json" | jq --arg seq "$new_seq" '.data.seq = $seq')
      if echo "$update_json" | "${KUBECTL[@]}" replace -f - >/dev/null 2>&1; then
        break
      fi

      # 409 Conflict — retry.
      retries=$((retries + 1))
      if [ "$retries" -ge "$MAX_CAS_RETRIES" ]; then
        echo "record: CAS failed after $MAX_CAS_RETRIES retries" >&2
        exit 1
      fi
    done

    # Fill seq and ts in event JSON.
    ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    event_json=$(echo "$event_json" | jq \
      --argjson seq "$new_seq" \
      --arg ts "$ts" \
      '.seq = $seq | .ts = $ts')

    # Extract type and actor for labels.
    evt_type=$(echo "$event_json" | jq -r '.type // "unknown"')
    evt_actor=$(echo "$event_json" | jq -r '.actor // "unknown"')

    # Sanitize label values: lowercase, alphanumeric/dash/underscore/dot, max 63 chars.
    evt_type_label=$(echo "$evt_type" | sed 's/[^a-zA-Z0-9._-]/_/g' | cut -c1-63)
    evt_actor_label=$(echo "$evt_actor" | sed 's/[^a-zA-Z0-9._-]/_/g' | cut -c1-63)

    # Create event ConfigMap as JSON (avoids YAML escaping of nested JSON).
    name=$(cm_name "$new_seq")
    evt_compact=$(echo "$event_json" | jq -c '.')
    jq -n \
      --arg name "$name" \
      --arg ns "$NS" \
      --arg managed "$MANAGED_BY" \
      --arg component "$COMPONENT_EVENT" \
      --arg etype "$evt_type_label" \
      --arg eactor "$evt_actor_label" \
      --arg event "$evt_compact" \
      '{
        apiVersion: "v1",
        kind: "ConfigMap",
        metadata: {
          name: $name,
          namespace: $ns,
          labels: {
            "app.kubernetes.io/managed-by": $managed,
            "gc/component": $component,
            "gc/type": $etype,
            "gc/actor": $eactor
          }
        },
        data: {
          event: $event
        }
      }' | "${KUBECTL[@]}" apply -f - >/dev/null
    ;;

  list)
    # Read filter JSON from stdin (default to empty object).
    filter_json=$(cat || true)
    if [ -z "$filter_json" ] || ! echo "$filter_json" | jq empty 2>/dev/null; then
      filter_json='{}'
    fi

    # Build label selector.
    selectors="gc/component=$COMPONENT_EVENT"

    filter_type=$(echo "$filter_json" | jq -r '.Type // empty')
    if [ -n "${filter_type:-}" ]; then
      type_label=$(echo "$filter_type" | sed 's/[^a-zA-Z0-9._-]/_/g' | cut -c1-63)
      selectors="${selectors},gc/type=${type_label}"
    fi

    filter_actor=$(echo "$filter_json" | jq -r '.Actor // empty')
    if [ -n "${filter_actor:-}" ]; then
      actor_label=$(echo "$filter_actor" | sed 's/[^a-zA-Z0-9._-]/_/g' | cut -c1-63)
      selectors="${selectors},gc/actor=${actor_label}"
    fi

    # Get all matching ConfigMaps.
    cms=$("${KUBECTL[@]}" get configmaps -l "$selectors" -o json 2>/dev/null) || {
      echo "[]"
      exit 0
    }

    # Extract event JSON from each ConfigMap, apply remaining filters.
    after_seq=$(echo "$filter_json" | jq -r '.AfterSeq // 0' 2>/dev/null || echo "0")
    after_seq="${after_seq:-0}"
    since=$(echo "$filter_json" | jq -r '.Since // empty' 2>/dev/null || true)

    echo "$cms" | jq -c --argjson after_seq "$after_seq" --arg since "${since:-}" '
      [.items[]
        | .data.event
        | fromjson
        | select(.seq > $after_seq)
        | select(
            if $since != "" and $since != "0001-01-01T00:00:00Z" then
              .ts >= $since
            else true end
          )
      ] | sort_by(.seq)'
    ;;

  latest-seq)
    seq=$("${KUBECTL[@]}" get configmap "$SEQ_CM" \
      -o jsonpath='{.data.seq}' 2>/dev/null || true)
    echo "${seq:-0}"
    ;;

  watch)
    after_seq="${1:-0}"

    # Long-running: stream ConfigMap watch events, filter to ADDED events
    # with seq > afterSeq, output NDJSON.
    "${KUBECTL[@]}" get configmaps \
      -l "gc/component=$COMPONENT_EVENT" \
      --watch -o json --output-watch-events 2>/dev/null \
      | jq -c --unbuffered --argjson after_seq "$after_seq" '
          select(.type == "ADDED")
          | .object.data.event
          | fromjson
          | select(.seq > $after_seq)
        ' 2>/dev/null
    ;;

  *)
    # Unknown operation — exit 2 for forward compatibility.
    exit 2
    ;;
esac
