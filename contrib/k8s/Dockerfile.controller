# Gas City controller container image.
#
# Extends the agent image with kubectl and K8s helper scripts.
# The controller runs gc start --foreground inside a pod, managing agent
# pods via client-go (native K8s session provider) and the K8s API.
#
# Build:
#   docker build -f contrib/k8s/Dockerfile.controller -t gc-controller:latest .
#
# The gc-agent image must be built first:
#   docker build -f contrib/k8s/Dockerfile.agent -t gc-agent:latest .

ARG BASE=gc-agent:latest
FROM ${BASE}

# Controller installs to /usr/local/bin â€” need root.
USER root

# kubectl for agent attach and beads/events exec providers.
RUN curl -fsSL "https://dl.k8s.io/release/$(curl -Ls \
    https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" \
    -o /usr/local/bin/kubectl && chmod +x /usr/local/bin/kubectl

# K8s provider scripts (beads, events). Session provider is now native
# (compiled into gc binary as GC_SESSION=k8s).
COPY contrib/beads-scripts/gc-beads-k8s /usr/local/bin/gc-beads-k8s
COPY contrib/events-scripts/gc-events-k8s /usr/local/bin/gc-events-k8s

WORKDIR /city

# Wait for city directory to be copied in (via gc-controller-k8s deploy),
# then init from it and wait for the deploy script to finish setup (bd init
# for scale_check) before starting the controller.
CMD ["sh", "-c", \
  "while [ ! -f /city/city.toml ]; do sleep 1; done && \
   cp -r /city /tmp/city-src && \
   gc init --from /tmp/city-src /city && \
   touch /city/.gc-init-done && \
   while [ ! -f /city/.gc-start ]; do sleep 0.5; done && \
   exec gc start --foreground /city"]
