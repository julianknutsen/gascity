#!/usr/bin/env bash
# gc-beads-k8s — Kubernetes beads provider for Gas City.
#
# Implements the exec beads provider protocol, running bd commands inside a
# lightweight "beads runner" pod via kubectl exec. The beads runner pod
# connects to Dolt running as a StatefulSet inside the cluster — no
# port-forwarding needed from the controller's laptop.
#
# Same pattern as gc-session-k8s (sessions) and gc-events-k8s (events):
# the controller shells out to kubectl, which execs into the pod.
#
# See docs/exec-beads-protocol.md for the full protocol specification.
#
# Dependencies: kubectl, jq, bash
# Container requirements: bd, jq, bash, git
#
# Usage: GC_BEADS=exec:/path/to/gc-beads-k8s gc start <city>
#
# Configuration via environment variables:
#
#   GC_K8S_NAMESPACE   - K8s namespace (default: gc)
#   GC_K8S_CONTEXT     - kubectl context (default: current)
#   GC_K8S_IMAGE       - Container image (required for ensure-ready)
#   GC_K8S_DOLT_HOST   - Dolt service DNS (default: dolt.gc.svc.cluster.local)
#   GC_K8S_DOLT_PORT   - Dolt service port (default: 3307)
#
# Label conventions (same as gc-beads-br):
#   parent:<id>  — tracks parent-child relationships
#   meta:<k>=<v> — stores metadata as labels
#   needs:<id>   — tracks step dependencies

set -euo pipefail

op="${1:?usage: gc-beads-k8s <operation> [args...]}"
shift

# --- Configuration ---

NS="${GC_K8S_NAMESPACE:-gc}"
IMAGE="${GC_K8S_IMAGE:-}"
DOLT_HOST="${GC_K8S_DOLT_HOST:-dolt.gc.svc.cluster.local}"
DOLT_PORT="${GC_K8S_DOLT_PORT:-3307}"

POD_NAME="gc-beads-runner"

# Build kubectl base command with optional context.
KUBECTL=(kubectl)
if [ -n "${GC_K8S_CONTEXT:-}" ]; then
  KUBECTL+=(--context "$GC_K8S_CONTEXT")
fi
KUBECTL+=(-n "$NS")

# --- Helpers ---

# run_bd executes bd inside the beads runner pod.
run_bd() { "${KUBECTL[@]}" exec "$POD_NAME" -- bd "$@"; }

# run_bd_stdin executes bd inside the beads runner pod with stdin piped through.
run_bd_stdin() { "${KUBECTL[@]}" exec -i "$POD_NAME" -- bd "$@"; }

# bd_to_gc converts a single bd JSON object to Gas City wire format.
# bd uses "issue_type" where Gas City uses "type".
bd_to_gc() {
  jq '{
    id: .id,
    title: .title,
    status: (if .status == "blocked" or .status == "review" or .status == "testing" then "open" else .status end),
    type: (.issue_type // .type // "task"),
    created_at: .created_at,
    assignee: (.assignee // ""),
    parent_id: (
      [.labels // [] | .[] | select(startswith("parent:")) | ltrimstr("parent:")] | first // ""
    ),
    ref: (.ref // ""),
    needs: [.labels // [] | .[] | select(startswith("needs:")) | ltrimstr("needs:")],
    description: (.description // ""),
    labels: [.labels // [] | .[] | select((startswith("parent:") or startswith("meta:") or startswith("needs:")) | not)]
  }'
}

# bd_list_to_gc converts a bd JSON array to Gas City wire format.
bd_list_to_gc() {
  jq '[.[] | {
    id: .id,
    title: .title,
    status: (if .status == "blocked" or .status == "review" or .status == "testing" then "open" else .status end),
    type: (.issue_type // .type // "task"),
    created_at: .created_at,
    assignee: (.assignee // ""),
    parent_id: (
      [.labels // [] | .[] | select(startswith("parent:")) | ltrimstr("parent:")] | first // ""
    ),
    ref: (.ref // ""),
    needs: [.labels // [] | .[] | select(startswith("needs:")) | ltrimstr("needs:")],
    description: (.description // ""),
    labels: [.labels // [] | .[] | select((startswith("parent:") or startswith("meta:") or startswith("needs:")) | not)]
  }]'
}

# join_labels joins an array of labels with commas for bd --labels flag.
join_labels() {
  local IFS=","
  echo "$*"
}

# --- Operations ---

case "$op" in
  ensure-ready)
    if [ -z "$IMAGE" ]; then
      echo "ensure-ready: GC_K8S_IMAGE is required" >&2
      exit 1
    fi

    # 1. Check if pod already Running.
    phase=$("${KUBECTL[@]}" get pod "$POD_NAME" -o jsonpath='{.status.phase}' 2>/dev/null || true)
    if [ "$phase" = "Running" ]; then
      exit 0
    fi

    # 2. Delete stale pod if exists (non-Running).
    if [ -n "$phase" ]; then
      "${KUBECTL[@]}" delete pod "$POD_NAME" --ignore-not-found --wait=false >/dev/null 2>&1 || true
      # Wait for deletion to complete before recreating.
      "${KUBECTL[@]}" wait --for=delete "pod/$POD_NAME" --timeout=30s >/dev/null 2>&1 || true
    fi

    # 3. Create pod manifest via jq (no YAML interpolation — safe from injection).
    manifest=$(jq -n \
      --arg pod "$POD_NAME" \
      --arg ns "$NS" \
      --arg image "$IMAGE" \
      --arg dolt_host "$DOLT_HOST" \
      --arg dolt_port "$DOLT_PORT" \
      '{
        apiVersion: "v1",
        kind: "Pod",
        metadata: {
          name: $pod,
          namespace: $ns,
          labels: {
            "app.kubernetes.io/managed-by": "gascity",
            "gc/component": "beads-runner"
          }
        },
        spec: {
          restartPolicy: "Never",
          securityContext: {runAsUser: 0},
          containers: [{
            name: "beads",
            image: $image,
            imagePullPolicy: "IfNotPresent",
            workingDir: "/workspace/beads",
            command: ["/bin/sh", "-c"],
            args: ["mkdir -p /workspace/beads && cd /workspace/beads && git init --quiet 2>/dev/null; tail -f /dev/null"],
            env: [
              {name: "GC_DOLT_HOST", value: $dolt_host},
              {name: "GC_DOLT_PORT", value: $dolt_port}
            ],
            resources: {
              requests: {cpu: "100m", memory: "128Mi"},
              limits: {cpu: "500m", memory: "512Mi"}
            }
          }]
        }
      }')

    echo "$manifest" | "${KUBECTL[@]}" apply -f - >/dev/null

    # 4. Wait for Ready.
    if ! "${KUBECTL[@]}" wait --for=condition=Ready "pod/$POD_NAME" --timeout=120s >/dev/null 2>&1; then
      pod_phase=$("${KUBECTL[@]}" get pod "$POD_NAME" -o jsonpath='{.status.phase}' 2>/dev/null || true)
      echo "ensure-ready: pod $POD_NAME not ready after 120s (phase: ${pod_phase:-unknown})" >&2
      exit 1
    fi

    # 5. Initialize beads if not already done.
    if ! "${KUBECTL[@]}" exec "$POD_NAME" -- test -f /workspace/beads/.beads/metadata.json 2>/dev/null; then
      run_bd init --server --server-host "$DOLT_HOST" --server-port "$DOLT_PORT" \
        -p gc --skip-hooks >/dev/null 2>&1
      run_bd config set issue_prefix gc >/dev/null 2>&1
    fi
    ;;

  shutdown)
    "${KUBECTL[@]}" delete pod "$POD_NAME" --ignore-not-found >/dev/null 2>&1 || true
    ;;

  init)
    # dir=$1 (ignored — beads runner has fixed workdir)
    prefix="${2:?init: missing prefix}"
    run_bd init --server --server-host "$DOLT_HOST" --server-port "$DOLT_PORT" \
      -p "$prefix" --skip-hooks >/dev/null 2>&1
    run_bd config set issue_prefix "$prefix" >/dev/null 2>&1
    ;;

  config-set)
    key="${1:?config-set: missing key}"
    value="${2:?config-set: missing value}"
    run_bd config set "$key" "$value" >/dev/null 2>&1
    ;;

  create)
    input=$(cat)
    title=$(echo "$input" | jq -r '.title')
    bead_type=$(echo "$input" | jq -r '.type // "task"')
    parent_id=$(echo "$input" | jq -r '.parent_id // ""')
    ref=$(echo "$input" | jq -r '.ref // ""')
    description=$(echo "$input" | jq -r '.description // ""')

    # Collect all labels into an array.
    all_labels=()
    # User-provided labels.
    while IFS= read -r label; do
      [ -n "$label" ] && all_labels+=("$label")
    done < <(echo "$input" | jq -r '.labels // [] | .[]')

    # Parent tracking via label.
    [ -n "$parent_id" ] && all_labels+=("parent:$parent_id")

    # Needs tracking via labels.
    while IFS= read -r need; do
      [ -n "$need" ] && all_labels+=("needs:$need")
    done < <(echo "$input" | jq -r '.needs // [] | .[]')

    # Build create command.
    cmd_args=(create --json --type="$bead_type")
    [ -n "$description" ] && cmd_args+=(--description "$description")
    if [ ${#all_labels[@]} -gt 0 ]; then
      cmd_args+=(--labels "$(join_labels "${all_labels[@]}")")
    fi
    cmd_args+=("$title")

    run_bd "${cmd_args[@]}" | bd_to_gc
    ;;

  get)
    id="${1:?get: missing id}"
    # bd show returns an array; extract the first element.
    run_bd show --json "$id" | jq '.[0]' | bd_to_gc
    ;;

  update)
    id="${1:?update: missing id}"
    input=$(cat)
    cmd_args=(update --json "$id")

    description=$(echo "$input" | jq -r '.description // empty')
    [ -n "$description" ] && cmd_args+=(--description "$description")

    # Append labels via --add-label (one per flag).
    while IFS= read -r label; do
      [ -n "$label" ] && cmd_args+=(--add-label "$label")
    done < <(echo "$input" | jq -r '.labels // [] | .[]')

    # Handle parent_id change.
    parent_id=$(echo "$input" | jq -r '.parent_id // empty')
    [ -n "$parent_id" ] && cmd_args+=(--add-label "parent:$parent_id")

    run_bd "${cmd_args[@]}" > /dev/null
    ;;

  close)
    id="${1:?close: missing id}"
    run_bd close --json "$id" > /dev/null
    ;;

  list)
    run_bd list --json --limit 0 --all | bd_list_to_gc
    ;;

  ready)
    run_bd ready --json --limit 0 | bd_list_to_gc
    ;;

  children)
    parent_id="${1:?children: missing parent_id}"
    # Sort by created_at to match the "in creation order" contract.
    run_bd list --json --all --label "parent:$parent_id" | bd_list_to_gc | jq 'sort_by(.created_at)'
    ;;

  list-by-label)
    label="${1:?list-by-label: missing label}"
    limit="${2:-0}"
    if [ "$limit" -gt 0 ] 2>/dev/null; then
      run_bd list --json --all --label "$label" --limit "$limit" | bd_list_to_gc
    else
      run_bd list --json --all --label "$label" | bd_list_to_gc
    fi
    ;;

  set-metadata)
    id="${1:?set-metadata: missing id}"
    key="${2:?set-metadata: missing key}"
    value=$(cat)
    run_bd update --json "$id" --add-label "meta:${key}=${value}" > /dev/null
    ;;

  mol-cook|purge)
    exit 2  # Composed in Go / not supported in Phase 1
    ;;

  *)
    exit 2  # Unknown operation
    ;;
esac
