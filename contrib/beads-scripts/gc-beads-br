#!/usr/bin/env bash
# gc-beads-br — Gas City exec beads provider wrapping beads_rust (br CLI).
#
# Usage:
#   export GC_BEADS=exec:/path/to/contrib/beads-scripts/gc-beads-br
#   gc start my-city
#
# Dependencies: br (beads_rust), jq, bash
#
# Label conventions:
#   parent:<id>  — tracks parent-child relationships
#   meta:<k>=<v> — stores metadata as labels
#   needs:<id>   — tracks step dependencies
#
# Operations that Gas City composes in Go (exit 2):
#   mol-cook  — composed from Create calls by exec.Store
#   init      — not needed (br init is separate)
#   config-set — not applicable
#   purge     — not supported
set -euo pipefail

op="${1:?usage: gc-beads-br <operation> [args...]}"
shift

# If BR_DIR is set, change to that directory so br uses it as the store root.
if [ -n "${BR_DIR:-}" ]; then
  cd "$BR_DIR"
fi

# br_to_gc converts a single br JSON object to Gas City wire format.
# br uses "issue_type" where Gas City uses "type".
br_to_gc() {
  jq '{
    id: .id,
    title: .title,
    status: (if .status == "blocked" or .status == "review" or .status == "testing" then "open" else .status end),
    type: (.issue_type // .type // "task"),
    created_at: .created_at,
    assignee: (.assignee // ""),
    parent_id: (
      [.labels // [] | .[] | select(startswith("parent:")) | ltrimstr("parent:")] | first // ""
    ),
    ref: (.ref // ""),
    needs: [.labels // [] | .[] | select(startswith("needs:")) | ltrimstr("needs:")],
    description: (.description // ""),
    labels: [.labels // [] | .[] | select((startswith("parent:") or startswith("meta:") or startswith("needs:")) | not)]
  }'
}

# br_list_to_gc converts a br JSON array to Gas City wire format.
br_list_to_gc() {
  jq '[.[] | {
    id: .id,
    title: .title,
    status: (if .status == "blocked" or .status == "review" or .status == "testing" then "open" else .status end),
    type: (.issue_type // .type // "task"),
    created_at: .created_at,
    assignee: (.assignee // ""),
    parent_id: (
      [.labels // [] | .[] | select(startswith("parent:")) | ltrimstr("parent:")] | first // ""
    ),
    ref: (.ref // ""),
    needs: [.labels // [] | .[] | select(startswith("needs:")) | ltrimstr("needs:")],
    description: (.description // ""),
    labels: [.labels // [] | .[] | select((startswith("parent:") or startswith("meta:") or startswith("needs:")) | not)]
  }]'
}

# join_labels joins an array of labels with commas for br --labels flag.
join_labels() {
  local IFS=","
  echo "$*"
}

case "$op" in
  create)
    input=$(cat)
    title=$(echo "$input" | jq -r '.title')
    bead_type=$(echo "$input" | jq -r '.type // "task"')
    parent_id=$(echo "$input" | jq -r '.parent_id // ""')
    ref=$(echo "$input" | jq -r '.ref // ""')
    description=$(echo "$input" | jq -r '.description // ""')

    # Collect all labels into an array.
    all_labels=()
    # User-provided labels.
    while IFS= read -r label; do
      [ -n "$label" ] && all_labels+=("$label")
    done < <(echo "$input" | jq -r '.labels // [] | .[]')

    # Parent tracking via label.
    [ -n "$parent_id" ] && all_labels+=("parent:$parent_id")

    # Needs tracking via labels.
    while IFS= read -r need; do
      [ -n "$need" ] && all_labels+=("needs:$need")
    done < <(echo "$input" | jq -r '.needs // [] | .[]')

    # Build create command.
    cmd_args=(br create --json --type="$bead_type")
    [ -n "$description" ] && cmd_args+=(--description "$description")
    if [ ${#all_labels[@]} -gt 0 ]; then
      cmd_args+=(--labels "$(join_labels "${all_labels[@]}")")
    fi
    cmd_args+=("$title")

    "${cmd_args[@]}" | br_to_gc
    ;;

  get)
    # br show returns an array; extract the first element.
    br show --json "$1" | jq '.[0]' | br_to_gc
    ;;

  update)
    id="$1"
    input=$(cat)
    cmd_args=(br update --json "$id")

    description=$(echo "$input" | jq -r '.description // empty')
    [ -n "$description" ] && cmd_args+=(--description "$description")

    # Append labels via --add-label (one per flag).
    while IFS= read -r label; do
      [ -n "$label" ] && cmd_args+=(--add-label "$label")
    done < <(echo "$input" | jq -r '.labels // [] | .[]')

    # Handle parent_id change.
    parent_id=$(echo "$input" | jq -r '.parent_id // empty')
    [ -n "$parent_id" ] && cmd_args+=(--add-label "parent:$parent_id")

    "${cmd_args[@]}" > /dev/null
    ;;

  close)
    br close --json "$1" > /dev/null
    ;;

  list)
    br list --json --all | br_list_to_gc
    ;;

  ready)
    br ready --json | br_list_to_gc
    ;;

  children)
    parent_id="$1"
    # Sort by created_at to match the "in creation order" contract.
    br list --json --all --label "parent:$parent_id" | br_list_to_gc | jq 'sort_by(.created_at)'
    ;;

  list-by-label)
    label="$1"
    limit="${2:-0}"
    if [ "$limit" -gt 0 ] 2>/dev/null; then
      br list --json --all --label "$label" --limit "$limit" | br_list_to_gc
    else
      br list --json --all --label "$label" | br_list_to_gc
    fi
    ;;

  set-metadata)
    id="$1"
    key="$2"
    value=$(cat)
    br update --json "$id" --add-label "meta:${key}=${value}" > /dev/null
    ;;

  ensure-ready|shutdown)
    exit 2  # br is always ready, no server lifecycle
    ;;

  mol-cook|init|config-set|purge)
    exit 2  # Composed in Go / not applicable
    ;;

  *)
    exit 2  # Unknown operation
    ;;
esac
