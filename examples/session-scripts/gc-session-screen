#!/usr/bin/env bash
# gc-session-screen — GNU screen session provider for Gas City.
#
# Implements the exec session provider protocol.
# See README.md in this directory for the full protocol specification.
#
# Dependencies: screen, jq, bash
#
# Usage: GC_SESSION=exec:/path/to/gc-session-screen gc start <city>

set -euo pipefail

op="${1:?missing operation}"
name="${2:-}"

# State directory for metadata sidecar files.
STATE_DIR="${GC_EXEC_STATE_DIR:-${TMPDIR:-/tmp}/gc-session-screen}"
mkdir -p "$STATE_DIR"

case "$op" in
  start)
    # Read JSON config from stdin.
    config=$(cat)
    work_dir=$(echo "$config" | jq -r '.work_dir // empty')
    command=$(echo "$config" | jq -r '.command // empty')
    env_json=$(echo "$config" | jq -r '.env // {} | to_entries[] | "\(.key)=\(.value)"' 2>/dev/null || true)

    if [ -z "$name" ]; then
      echo "start: missing session name" >&2
      exit 1
    fi

    # Check if session already exists.
    if screen -list 2>/dev/null | grep -q "[[:space:]]${name}[[:space:]]"; then
      echo "session \"$name\" already exists" >&2
      exit 1
    fi

    # Build a wrapper script that sets env vars, cd, and exec the command.
    wrapper="$STATE_DIR/${name}.wrapper.sh"
    {
      echo "#!/bin/sh"
      # Export environment variables.
      if [ -n "$env_json" ]; then
        while IFS= read -r line; do
          echo "export '$line'"
        done <<< "$env_json"
      fi
      # Change to working directory.
      if [ -n "$work_dir" ]; then
        echo "cd '$work_dir'"
      fi
      # Run the command or default shell.
      if [ -n "$command" ]; then
        echo "exec $command"
      else
        echo "exec \$SHELL"
      fi
    } > "$wrapper"
    chmod +x "$wrapper"

    screen -dmS "$name" "$wrapper"
    ;;

  stop)
    if [ -z "$name" ]; then
      echo "stop: missing session name" >&2
      exit 1
    fi
    # Idempotent: no error if session doesn't exist.
    screen -S "$name" -X quit 2>/dev/null || true
    # Clean up wrapper and metadata.
    rm -f "$STATE_DIR/${name}.wrapper.sh"
    rm -f "$STATE_DIR/${name}".meta.*
    ;;

  interrupt)
    if [ -z "$name" ]; then exit 0; fi
    # Send Ctrl-C (0x03) to the session.
    screen -S "$name" -X stuff $'\x03' 2>/dev/null || true
    ;;

  is-running)
    if [ -z "$name" ]; then
      echo "false"
      exit 0
    fi
    if screen -list 2>/dev/null | grep -q "[[:space:]]${name}[[:space:]]"; then
      echo "true"
    else
      echo "false"
    fi
    ;;

  attach)
    if [ -z "$name" ]; then
      echo "attach: missing session name" >&2
      exit 1
    fi
    exec screen -r "$name"
    ;;

  process-alive)
    # Read process names from stdin (one per line).
    if [ -z "$name" ]; then
      echo "true"
      exit 0
    fi
    process_names=()
    while IFS= read -r pname; do
      [ -n "$pname" ] && process_names+=("$pname")
    done
    if [ ${#process_names[@]} -eq 0 ]; then
      echo "true"
      exit 0
    fi
    # Find the screen session's PID and check its process tree.
    screen_pid=$(screen -list 2>/dev/null | grep "[[:space:]]${name}[[:space:]]" | awk '{print $1}' | cut -d. -f1)
    if [ -z "$screen_pid" ]; then
      echo "false"
      exit 0
    fi
    # Walk the process tree looking for any matching process name.
    for pname in "${process_names[@]}"; do
      if pgrep -P "$screen_pid" -f "$pname" >/dev/null 2>&1; then
        echo "true"
        exit 0
      fi
    done
    echo "false"
    ;;

  nudge)
    if [ -z "$name" ]; then exit 0; fi
    msg=$(cat)
    # Type the message followed by Enter into the screen session.
    screen -S "$name" -X stuff "${msg}
" 2>/dev/null || true
    ;;

  set-meta)
    key="${3:?set-meta: missing key}"
    value=$(cat)
    echo -n "$value" > "$STATE_DIR/${name}.meta.${key}"
    ;;

  get-meta)
    key="${3:?get-meta: missing key}"
    meta_file="$STATE_DIR/${name}.meta.${key}"
    if [ -f "$meta_file" ]; then
      cat "$meta_file"
    fi
    # Empty stdout = not set (per protocol).
    ;;

  remove-meta)
    key="${3:?remove-meta: missing key}"
    rm -f "$STATE_DIR/${name}.meta.${key}"
    ;;

  peek)
    lines="${3:-0}"
    if [ -z "$name" ]; then
      exit 0
    fi
    # Use hardcopy to capture screen content.
    tmp=$(mktemp)
    screen -S "$name" -X hardcopy -h "$tmp" 2>/dev/null || { rm -f "$tmp"; exit 0; }
    if [ "$lines" -gt 0 ] 2>/dev/null; then
      tail -n "$lines" "$tmp"
    else
      cat "$tmp"
    fi
    rm -f "$tmp"
    ;;

  list-running)
    prefix="${name:-}"
    # Parse screen -list output, filter by prefix.
    screen -list 2>/dev/null | grep -oP '\d+\.\K[^\t]+' | while IFS= read -r sess; do
      if [ -z "$prefix" ] || [[ "$sess" == "$prefix"* ]]; then
        echo "$sess"
      fi
    done
    # Exit 0 even if no sessions found.
    exit 0
    ;;

  get-last-activity)
    # GNU screen does not expose activity timestamps.
    # Empty stdout = unsupported (per protocol).
    ;;

  *)
    # Unknown operation — exit 2 for forward compatibility.
    exit 2
    ;;
esac
