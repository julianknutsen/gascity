description = """
Refinery patrol loop. Poured as a wisp on startup:

  bd mol wisp mol-refinery-patrol
  bd update $WISP --assignee=$GC_AGENT

Each wisp is ONE iteration: check for work, merge one branch, pour
the next iteration. On crash, `bd mol current` shows exactly where
you left off.

The loop mechanism: every exit path (happy or early) pours the next
wisp before burning this one. The prompt only bootstraps the first wisp.

Work beads flow directly: pool → polecat → refinery → closed.
No separate MR beads. The polecat sets metadata (branch, target) on
the work bead and assigns it to the refinery. On rejection, the
refinery puts the bead back in the pool with rejection metadata.

Read each step's description before acting — Config values override defaults."""
formula = "mol-refinery-patrol"
version = 1

[vars]
[vars.run_tests]
description = "Whether to run tests before merging"
default = "true"

[vars.setup_command]
description = "Setup/install command (e.g., pnpm install). Empty = skip."
default = ""

[vars.typecheck_command]
description = "Type check command (e.g., tsc --noEmit). Empty = skip."
default = ""

[vars.lint_command]
description = "Lint command (e.g., eslint .). Empty = skip."
default = ""

[vars.test_command]
description = "Test command to run (if run_tests is true)"
default = ""

[vars.build_command]
description = "Build command (e.g., go build ./...). Empty = skip."
default = ""

[vars.target_branch]
description = "Default target branch for merges"
default = "main"

[vars.delete_merged_branches]
description = "Whether to delete source branches after merge"
default = "true"

[vars.integration_branch_auto_land]
description = "Auto-create work beads to land completed integration branches"
default = "false"

[vars.event_timeout]
description = "Seconds to wait for events before re-checking (exponential backoff)"
default = "30"

[[steps]]
id = "check-inbox"
title = "Context check, then mail"
description = """
**1. Context check (FIRST — before any work):**
```bash
RSS=$(ps -o rss= -p $$ | tr -d ' ')
RSS_MB=$((RSS / 1024))
```

If RSS > 1500 MB or context feels heavy, request a restart:
```bash
gc agent request-restart
```
This sets `GC_RESTART_REQUESTED` metadata on the session and blocks
forever. The controller will kill and restart the session on the next
reconcile tick. The current wisp stays assigned and the new session
resumes it via `bd mol current`.

**2. Check mail:**
```bash
gc mail inbox
```

Archive any messages you handle. Note any context relevant to
upcoming merge work (e.g., priority overrides, hold requests).

Close this step and proceed."""

[[steps]]
id = "find-work"
title = "Find next work bead assigned to me or wait"
needs = ["check-inbox"]
description = """
**Config: event_timeout = {{event_timeout}}**

Search for work beads assigned to you with branch metadata:
```bash
WORK=$(bd list --assignee=$GC_AGENT --status=open \
  --limit=1 --json | jq -r '.[0].id // empty')
```

If found: read the bead metadata to confirm it has a branch:
```bash
bd show $WORK --json | jq '.metadata'
```
The bead MUST have `metadata.branch`. If `metadata.target` is missing,
use {{target_branch}} as default. Note the work bead ID and close this step.

If NO work found: wait for assignment:
```bash
SEQ=$(gc events --seq)
gc events --watch --type=bead.updated \
  --after=$SEQ --timeout {{event_timeout}}s
```

On event: re-check for assigned work. If found, close this step.
On timeout: re-check anyway, then wait again with doubled timeout (cap 300s).

**Do not close this step until you have a work bead with branch metadata.**"""

[[steps]]
id = "rebase"
title = "Rebase branch on target"
needs = ["find-work"]
description = """
**Config: target_branch = {{target_branch}}**

Read the work bead metadata:
```bash
BRANCH=$(bd show $WORK --json | jq -r '.metadata.branch')
TARGET=$(bd show $WORK --json | jq -r '.metadata.target // "{{target_branch}}"')
```

Fetch and attempt mechanical rebase:
```bash
git fetch --prune origin
git checkout -b temp origin/$BRANCH
git rebase origin/$TARGET
```

If rebase SUCCEEDED (exit 0): close this step, proceed to run-tests.

If rebase FAILED (conflicts):

1. Abort: `git rebase --abort`
2. Put the work bead back in the pool with rejection metadata:
```bash
bd update $WORK --status=open --assignee="" \
  --set-metadata rejection_reason="Conflicts with $TARGET at $(git rev-parse origin/$TARGET)"
```
3. Do NOT delete the branch (new polecat needs it for conflict resolution).
4. Clean up temp branch: `git checkout {{target_branch}} && git branch -D temp`
5. Pour next patrol iteration before burning:
```bash
NEXT=$(bd mol wisp mol-refinery-patrol --json | jq -r '.new_epic_id')
bd update "$NEXT" --assignee=$GC_AGENT
```
6. Burn this wisp: `bd mol burn <wisp-id> --force`

**A new polecat will pick up the bead, see the branch and rejection,
rebase, and reassign to refinery.**"""

[[steps]]
id = "run-tests"
title = "Run quality checks and tests"
needs = ["rebase"]
description = """
**Config: run_tests = {{run_tests}}**
**Config: test_command = {{test_command}}**
**Config: setup_command = {{setup_command}}**
**Config: typecheck_command = {{typecheck_command}}**
**Config: lint_command = {{lint_command}}**
**Config: build_command = {{build_command}}**

Run each configured check in order (skip empty ones silently):
```bash
{{setup_command}}
{{typecheck_command}}
{{lint_command}}
{{build_command}}
```

If run_tests = "true":
```bash
{{test_command}}
```

If run_tests = "false": skip tests entirely.

Track results: which checks ran, pass/fail, specific failures.
Close this step when all checks complete (pass or fail)."""

[[steps]]
id = "handle-failures"
title = "Handle quality check or test failures"
needs = ["run-tests"]
description = """
If all checks and tests PASSED: close this step, proceed to merge-push.

If any check or test FAILED:

1. Diagnose: branch regression or pre-existing on target?

2. If branch caused it:
   - Put the work bead back in the pool with rejection metadata:
     ```bash
     bd update $WORK --status=open --assignee="" \
       --set-metadata rejection_reason="<failure summary>"
     ```
   - Delete branch: `git push origin --delete $BRANCH`
   - Clean up: `git checkout {{target_branch}} && git branch -D temp`
   - Pour next patrol iteration before burning:
     ```bash
     NEXT=$(bd mol wisp mol-refinery-patrol --json | jq -r '.new_epic_id')
     bd update "$NEXT" --assignee=$GC_AGENT
     ```
   - Burn this wisp: `bd mol burn <wisp-id> --force`

3. If pre-existing on target:
   - File bead: `bd create --type=bug --priority=1 --title="Pre-existing failure: <summary>"`
   - Proceed with merge (failure not caused by this branch)

**GATE**: Cannot merge without all checks passing OR pre-existing bug filed.
**FORBIDDEN**: Writing code to fix failures. You are a merge processor."""

[[steps]]
id = "merge-push"
title = "Merge and push"
needs = ["handle-failures"]
description = """
**Config: target_branch = {{target_branch}}**
**Config: delete_merged_branches = {{delete_merged_branches}}**

Read the merge target from the work bead metadata:
```bash
TARGET=$(bd show $WORK --json | jq -r '.metadata.target // "{{target_branch}}"')
```

**1. Merge and push:**
```bash
git checkout $TARGET
git merge --ff-only temp
git push origin $TARGET
```

**2. Verify push:**
```bash
git fetch origin
LOCAL=$(git rev-parse $TARGET)
REMOTE=$(git rev-parse origin/$TARGET)
[ "$LOCAL" = "$REMOTE" ] || echo "PUSH FAILED — do not proceed"
```
If SHAs differ: STOP. Debug and retry. Do NOT continue.

**3. Close work bead (REQUIRED):**
```bash
bd close $WORK --reason "Merged to $TARGET at $(git rev-parse --short HEAD)"
```

**4. Cleanup:**
```bash
git branch -d temp
```
If delete_merged_branches = "true": `git push origin --delete $BRANCH`

**GATE**: Push verified + work bead closed before closing this step."""

[[steps]]
id = "next-iteration"
title = "Prepare next patrol iteration"
needs = ["merge-push"]
description = """
**Config: integration_branch_auto_land = {{integration_branch_auto_land}}**

**1. Integration branch check (only if auto_land = "true"):**

If the merge target was an integration branch, check if the parent
epic is now fully closed:
```bash
bd list --type=epic --status=open
```
For each epic with an integration branch: if ALL children are closed,
create a work bead to land it and assign to self:
```bash
bd create --type=task \
  --title="Land integration branch: <epic-title>" \
  --assignee=$GC_AGENT \
  --metadata '{"branch":"<integration-branch>","target":"{{target_branch}}"}'
```
The next patrol iteration will pick it up and merge it normally.

If auto_land = "false": skip this entirely.

**2. Pour next iteration:**
```bash
NEXT=$(bd mol wisp mol-refinery-patrol --json | jq -r '.new_epic_id')
bd update "$NEXT" --assignee=$GC_AGENT
```

**4. Burn this wisp:**
```bash
bd mol burn <this-wisp-id> --force
```

Close this step. The new wisp is ready — `bd mol current` will find it."""
