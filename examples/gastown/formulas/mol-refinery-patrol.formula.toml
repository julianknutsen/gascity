description = """
Refinery patrol loop. Poured as a wisp on startup:

  bd mol wisp mol-refinery-patrol
  bd update $WISP --assignee=$GC_AGENT

Each wisp is ONE iteration: check for work, merge one branch, pour
the next iteration. On crash, `bd mol current` shows exactly where
you left off.

The loop mechanism: every exit path (happy or early) pours the next
wisp before burning this one. The prompt only bootstraps the first wisp.

Read each step's description before acting — Config values override defaults."""
formula = "mol-refinery-patrol"
version = 1

[vars]
[vars.run_tests]
description = "Whether to run tests before merging"
default = "true"

[vars.setup_command]
description = "Setup/install command (e.g., pnpm install). Empty = skip."
default = ""

[vars.typecheck_command]
description = "Type check command (e.g., tsc --noEmit). Empty = skip."
default = ""

[vars.lint_command]
description = "Lint command (e.g., eslint .). Empty = skip."
default = ""

[vars.test_command]
description = "Test command to run (if run_tests is true)"
default = "go test ./..."

[vars.build_command]
description = "Build command (e.g., go build ./...). Empty = skip."
default = ""

[vars.target_branch]
description = "Default target branch for merges"
default = "main"

[vars.delete_merged_branches]
description = "Whether to delete source branches after merge"
default = "true"

[vars.integration_branch_auto_land]
description = "Auto-create MR beads to land completed integration branches"
default = "false"

[vars.event_timeout]
description = "Seconds to wait for events before re-checking (exponential backoff)"
default = "30"

[[steps]]
id = "check-inbox"
title = "Check for mail and events"
description = """
Check mail for escalations or handoff context:
```bash
gc mail inbox
```

Archive any messages you handle. Note any context relevant to
upcoming merge work (e.g., priority overrides, hold requests).

If no mail, close this step and proceed."""

[[steps]]
id = "find-work"
title = "Find next merge request or wait"
needs = ["check-inbox"]
description = """
**Config: event_timeout = {{event_timeout}}**

Search for open merge requests:
```bash
MR=$(bd list --type=merge-request --status=open \
  --limit=1 --json | jq -r '.[0].id // empty')
```

If MR found: note the MR bead ID. Close this step, proceed to rebase.

If NO MR found: wait for one to appear:
```bash
SEQ=$(gc events --seq)
gc events --watch --type=bead.created \
  --payload-match type=merge-request \
  --after=$SEQ --timeout {{event_timeout}}s
```

On event: re-check for MRs. If found, close this step.
On timeout: re-check anyway, then wait again with doubled timeout (cap 300s).

**Do not close this step until you have an MR bead ID to process.**"""

[[steps]]
id = "rebase"
title = "Rebase branch on target"
needs = ["find-work"]
description = """
**Config: target_branch = {{target_branch}}**

Read the MR bead to get the branch name and source work bead:
```bash
bd show $MR --json
```
The MR bead MUST contain `branch` and `source_bead` fields.
Read the `target` field if present; otherwise use {{target_branch}}.

Fetch and attempt mechanical rebase:
```bash
git fetch --prune origin
git checkout -b temp origin/<branch>
git rebase origin/<target>
```

If rebase SUCCEEDED (exit 0): close this step, proceed to run-tests.

If rebase FAILED (conflicts):

1. Abort: `git rebase --abort`
2. Close MR bead with rejection:
```bash
bd close $MR --reason "Conflicts with <target> at $(git rev-parse origin/<target>)"
```
3. Reopen source work bead for a new polecat to pick up:
```bash
bd update <source_bead> --status=open --assignee=""
```
4. Do NOT delete the branch (polecat needs it for conflict resolution).
5. Clean up temp branch: `git checkout {{target_branch}} && git branch -D temp`
6. Pour next patrol iteration before burning:
```bash
NEXT=$(bd mol wisp mol-refinery-patrol --json | jq -r '.new_epic_id')
bd update "$NEXT" --assignee=$GC_AGENT
```
7. Burn this wisp: `bd mol burn <wisp-id> --force`

**A new polecat will rebase and resubmit. Your next wisp is ready.**"""

[[steps]]
id = "run-tests"
title = "Run quality checks and tests"
needs = ["rebase"]
description = """
**Config: run_tests = {{run_tests}}**
**Config: test_command = {{test_command}}**
**Config: setup_command = {{setup_command}}**
**Config: typecheck_command = {{typecheck_command}}**
**Config: lint_command = {{lint_command}}**
**Config: build_command = {{build_command}}**

Run each configured check in order (skip empty ones silently):
```bash
{{setup_command}}
{{typecheck_command}}
{{lint_command}}
{{build_command}}
```

If run_tests = "true":
```bash
{{test_command}}
```

If run_tests = "false": skip tests entirely.

Track results: which checks ran, pass/fail, specific failures.
Close this step when all checks complete (pass or fail)."""

[[steps]]
id = "handle-failures"
title = "Handle quality check or test failures"
needs = ["run-tests"]
description = """
If all checks and tests PASSED: close this step, proceed to merge-push.

If any check or test FAILED:

1. Diagnose: branch regression or pre-existing on target?

2. If branch caused it:
   - Close MR bead: `bd close $MR --reason "Rejected: <failure summary>"`
   - Reopen source work bead:
     `bd update <source_bead> --status=open --assignee=""`
   - Delete branch: `git push origin --delete <branch>`
   - Clean up: `git checkout {{target_branch}} && git branch -D temp`
   - Pour next patrol iteration before burning:
     ```bash
     NEXT=$(bd mol wisp mol-refinery-patrol --json | jq -r '.new_epic_id')
     bd update "$NEXT" --assignee=$GC_AGENT
     ```
   - Burn this wisp: `bd mol burn <wisp-id> --force`

3. If pre-existing on target:
   - File bead: `bd create --type=bug --priority=1 --title="Pre-existing failure: <summary>"`
   - Proceed with merge (failure not caused by this branch)

**GATE**: Cannot merge without all checks passing OR pre-existing bug filed.
**FORBIDDEN**: Writing code to fix failures. You are a merge processor."""

[[steps]]
id = "merge-push"
title = "Merge and push"
needs = ["handle-failures"]
description = """
**Config: target_branch = {{target_branch}}**
**Config: delete_merged_branches = {{delete_merged_branches}}**

Read the merge target from the MR bead (`target` field, or {{target_branch}}).

**1. Merge and push:**
```bash
git checkout <target>
git merge --ff-only temp
git push origin <target>
```

**2. Verify push:**
```bash
git fetch origin
LOCAL=$(git rev-parse <target>)
REMOTE=$(git rev-parse origin/<target>)
[ "$LOCAL" = "$REMOTE" ] || echo "PUSH FAILED — do not proceed"
```
If SHAs differ: STOP. Debug and retry. Do NOT continue.

**3. Close MR bead (REQUIRED):**
```bash
bd close $MR --reason "Merged to <target> at $(git rev-parse --short HEAD)"
```

**4. Cleanup:**
```bash
git branch -d temp
```
If delete_merged_branches = "true": `git push origin --delete <branch>`

**GATE**: Push verified + MR bead closed before closing this step."""

[[steps]]
id = "next-iteration"
title = "Prepare next patrol iteration"
needs = ["merge-push"]
description = """
**Config: integration_branch_auto_land = {{integration_branch_auto_land}}**

**1. Integration branch check (only if auto_land = "true"):**

If the merge target was an integration branch, check if the parent
epic is now fully closed:
```bash
bd list --type=epic --status=open
```
For each epic with an integration branch: if ALL children are closed,
create an MR bead to land it:
```bash
bd create --type=merge-request \
  --title="Land integration branch: <epic-title>" \
  --field branch=<integration-branch> \
  --field target={{target_branch}} \
  --field source_bead=<epic-id>
```
The next patrol iteration will pick it up and merge it normally.

If auto_land = "false": skip this entirely.

**2. Context check:**
```bash
RSS=$(ps -o rss= -p $$ | tr -d ' ')
RSS_MB=$((RSS / 1024))
```

If RSS > 1500 MB or context feels heavy:
```bash
gc mail send $GC_AGENT -s "HANDOFF" -m "Patrol iteration complete. RSS: ${RSS_MB}MB"
exit
```
The controller will restart a fresh refinery session.

**3. Pour next iteration:**
```bash
NEXT=$(bd mol wisp mol-refinery-patrol --json | jq -r '.new_epic_id')
bd update "$NEXT" --assignee=$GC_AGENT
```

**4. Burn this wisp:**
```bash
bd mol burn <this-wisp-id>
```

Close this step. The new wisp is ready — `bd mol current` will find it."""
